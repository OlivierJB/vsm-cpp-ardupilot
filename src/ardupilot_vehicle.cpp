// Copyright (c) 2014, Smart Projects Holdings Ltd
// All rights reserved.
// See LICENSE file for license details.

#include <ardupilot_vehicle.h>

const ugcs::vsm::Mavlink_demuxer::System_id Mavlink_vehicle::VSM_SYSTEM_ID = 1;

/* Reference Mavlink implementation (ArduPilot) source code
 * (as for 17-July-2013) has the following comment:
 *
 * "Currently we are not checking for correct compid since APM is not
 *  passing mavlink info to any subsystem.
 *  If it is addressed to our system ID we assume it is for us"
 *
 *  In other words, component ID is ignored when packet is received by
 *  APM. To make the situation even worse, all packets generated by APM
 *  has component ID of 1, which is a hard-coded value. Thats why here
 *  same default component ID is used for all operations.
 */
const ugcs::vsm::Mavlink_demuxer::Component_id Mavlink_vehicle::VSM_COMPONENT_ID = 1;
constexpr std::chrono::milliseconds Ardupilot_vehicle::RC_OVERRIDE_PERIOD;
constexpr std::chrono::milliseconds Ardupilot_vehicle::RC_OVERRIDE_TIMEOUT;

using namespace ugcs::vsm;

void
Ardupilot_vehicle::On_enable()
{
    // Get parameter values.
    Mavlink_vehicle::On_enable();
    read_version.version_handler = Read_version::Make_version_handler(
        &Ardupilot_vehicle::On_autopilot_version,
        Shared_from_this());

    // We need to understand only that FS_EKF_ACTION is supported.
    read_version.Enable();

    read_waypoints.item_handler = Read_waypoints::Make_mission_item_handler(
        &Ardupilot_vehicle::On_mission_item,
        Shared_from_this());

    // Poll for home location until it becomes valid.
    home_location_timer =
        Timer_processor::Get_instance()->Create_timer(
            std::chrono::seconds(3),
            Make_callback(
                &Ardupilot_vehicle::On_home_location_timer,
                Shared_from_this()),
            Get_completion_ctx());

    // Common capabilities to fixed and multicopter.

    c_arm->Set_available(true);
    c_disarm->Set_available(true);
    c_waypoint->Set_available(true);
    c_auto->Set_available(true);
    c_manual->Set_available(true);
    c_guided->Set_available(true);
    c_pause->Set_available(true);
    c_resume->Set_available(true);
    c_rth->Set_available(true);
    Get_home_location();

    if (type == ugcs::vsm::mavlink::MAV_TYPE_FIXED_WING) {
        c_set_parameter = Add_command(subsystems.fc, "set_parameter", false, true);
        c_set_parameter->Add_parameter("landing_flare_altitude",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_flare_time",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("min_landing_pitch",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_flare_damp",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_approach_airspeed",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_speed_weighting",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("max_auto_flight_pitch",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("max_pitch",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("min_throttle",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_sink_rate",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_rangefinder_enabled",Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("min_rangefinder_distance",Property::VALUE_TYPE_FLOAT);

        Set_rc_loss_actions({
            proto::FAILSAFE_ACTION_RTH,
            proto::FAILSAFE_ACTION_CONTINUE
            });

    } else {
        Set_rc_loss_actions({
            proto::FAILSAFE_ACTION_RTH,
            proto::FAILSAFE_ACTION_CONTINUE,
            proto::FAILSAFE_ACTION_LAND
            });

        Set_gps_loss_actions({
            proto::FAILSAFE_ACTION_WAIT,
            proto::FAILSAFE_ACTION_LAND
            });
    }

    Set_low_battery_actions({
        proto::FAILSAFE_ACTION_RTH,
        proto::FAILSAFE_ACTION_CONTINUE
        });
}

void
Ardupilot_vehicle::On_disable()
{
    home_location_timer->Cancel();
    if (rc_override_timer) {
        rc_override_timer->Cancel();
    }
    Mavlink_vehicle::On_disable();
}

void
Ardupilot_vehicle::On_autopilot_version(ugcs::vsm::mavlink::Pld_autopilot_version ver)
{
    int maj = (ver->flight_sw_version.Get() >> 24) & 0xff;
    int min = (ver->flight_sw_version.Get() >> 16) & 0xff;
    int patch = (ver->flight_sw_version.Get() >> 8) & 0xff;
    int type = (ver->flight_sw_version.Get() >> 0) & 0xff;
    LOG("Ardupilot version=%d.%d.%d, type=%d", maj, min, patch, type);

    if (ver->flight_sw_version.Get() >= ARDUPILOT_VERSION(3, 3, 1)) {
        use_ekf_action_as_gps_failsafe = true;
        send_home_position_as_mav_cmd = true;
    }
}

void
Ardupilot_vehicle::On_mission_item(ugcs::vsm::mavlink::Pld_mission_item mi)
{
    if (mi->seq == 0) {
        home_location.latitude = mi->x * M_PI / 180;
        home_location.longitude = mi->y * M_PI / 180;

        if (Is_home_position_valid()) {
            VEHICLE_LOG_INF(*this, "Got home position: x=%f, y=%f, z=%f. Setting altitude origin.", mi->x.Get(), mi->y.Get(), mi->z.Get());
            t_home_latitude->Set_value(home_location.latitude);
            t_home_longitude->Set_value(home_location.longitude);
            t_home_altitude_amsl->Set_value(mi->z.Get());
            Set_altitude_origin(mi->z.Get());
        }
    }
}

bool
Ardupilot_vehicle::Is_home_position_valid()
{
    return (home_location.latitude != 0) || (home_location.longitude != 0);
}

bool
Ardupilot_vehicle::On_home_location_timer()
{
    // Keep requesting HL until successful.
    if (!Is_home_position_valid()) {
        Get_home_location();
    }
    if (Get_completion_ctx()->Is_enabled()) {
        return true;
    }
    return false;
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_task_request::Handle request)
{
    VEHICLE_LOG_INF((*this), "Starting to handle %zu tasks...", request->actions.size());
    ASSERT(!task_upload.request);
    task_upload.Disable();
    task_upload.Enable(request);
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_command_request::Handle request)
{
    if (vehicle_command.vehicle_command_request) {
        request.Fail("Previous request in progress");
    } else {
        vehicle_command.Disable();
        vehicle_command.Enable(request);
    }
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type() const
{
    return Get_type(Get_mav_type());
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type(ugcs::vsm::mavlink::MAV_TYPE type)
{
    switch (type) {
    case mavlink::MAV_TYPE::MAV_TYPE_QUADROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_HEXAROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_OCTOROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_TRICOPTER:
    case mavlink::MAV_TYPE::MAV_TYPE_HELICOPTER:
    case mavlink::MAV_TYPE::MAV_TYPE_COAXIAL:
        return Type::COPTER;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_FIXED_WING:
        return Type::PLANE;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_GROUND_ROVER:
        return Type::ROVER;
        break;
    default:
        switch (static_cast<mavlink::ugcs::MAV_TYPE>(type)) {
            case mavlink::ugcs::MAV_TYPE::MAV_TYPE_IRIS:
                return Type::COPTER;
            default:
                break;
        }
        return Type::OTHER;
    }
}

bool
Ardupilot_vehicle::Vehicle_command_act::Try()
{
    if (!remaining_attempts--) {
        VEHICLE_LOG_WRN(vehicle, "Vehicle_command all attempts failed.");
        Disable();
        return false;
    }

    current_timeout = RETRY_TIMEOUT_SHORT;

    /* Create always, it will be assigned to cmd_message, if used. */
    auto cmd_long = mavlink::Pld_command_long::Create();
    mavlink::Pld_mission_item::Ptr cmd_mission_item;
    mavlink::Pld_set_mode::Ptr cmd_set_mode;
    mavlink::Pld_param_set::Ptr param;
    Fill_target_ids(*cmd_long);
    auto current_control_mode = ardu_vehicle.Get_system_status().control_mode;
    double heading;
    float pitch;
    float yaw;
    cmd_messages.clear();

    switch (vehicle_command_request->Get_type()) {

    case Vehicle_command::Type::RESUME_MISSION:
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "MIS_RESTART";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        (*param)->param_value = 0;
        cmd_messages.emplace_back(param);
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
        cmd_messages.emplace_back(cmd_long);
        break;

    case Vehicle_command::Type::AUTO_MODE:
        ardu_vehicle.Stop_rc_override();
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "MIS_RESTART";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        (*param)->param_value = 1;
        cmd_messages.emplace_back(param);
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
        cmd_messages.emplace_back(cmd_long);
        // Reset MIS_RESTART back to 0 so that next time user enters AUTO from
        // RC tx, vehicle continues mission instead of returning back to WP1.
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "MIS_RESTART";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        (*param)->param_value = 0;
        cmd_messages.emplace_back(param);
        break;

    case Vehicle_command::Type::MANUAL_MODE:
        /* Current Ardupilot firmware does not send responses to mode changes,
         * so just check the current mode as an indication of completed
         * request. */
        if (current_control_mode == Sys_status::Control_mode::MANUAL) {
            vehicle_command_request.Succeed();
        } else {
            cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
            Fill_target_system_id(*cmd_set_mode);
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
            cmd_messages.emplace_back(cmd_set_mode);
        }
        ardu_vehicle.Stop_rc_override();
        break;

    case Vehicle_command::Type::ARM:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
        (*cmd_long)->param1 = 1; /* Do arm. */
        cmd_messages.emplace_back(cmd_long);
        Register_status_text();
        break;

    case Vehicle_command::Type::DISARM:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
        (*cmd_long)->param1 = 0; /* Do disarm. */
        cmd_messages.emplace_back(cmd_long);
        break;

    case Vehicle_command::Type::PAUSE_MISSION:
        // If vehicle is in guided mode already then
        // briefly move into manual to reset current guided WP and then
        // switch back to guided so the vehicle hovers at current position.
        if (current_control_mode == Sys_status::Control_mode::GUIDED) {
            cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
            Fill_target_system_id(*cmd_set_mode);
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
            cmd_messages.emplace_back(cmd_set_mode);
        }
        // Enter GUIDED mode.
        cmd_set_mode = mavlink::Pld_set_mode::Create();
        (*cmd_set_mode)->target_system = vehicle.real_system_id;
        (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
        (*cmd_set_mode)->custom_mode = Get_custom_guided_mode();
        cmd_messages.emplace_back(cmd_set_mode);
        break;

    case Vehicle_command::Type::GUIDED_MODE:
        // Enter GUIDED mode.
        ardu_vehicle.Stop_rc_override();
        cmd_set_mode = mavlink::Pld_set_mode::Create();
        (*cmd_set_mode)->target_system = vehicle.real_system_id;
        (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
        (*cmd_set_mode)->custom_mode = Get_custom_guided_mode();
        cmd_messages.emplace_back(cmd_set_mode);
        break;

    case Vehicle_command::Type::WAYPOINT:
        // Does 4 things:
        // Enter guided mode if needed
        // Change current speed
        // Change yaw if needed
        // Got to WP
        if (current_control_mode != Sys_status::Control_mode::GUIDED) {
            ardu_vehicle.Stop_rc_override();
            // Enter GUIDED mode.
            cmd_set_mode = mavlink::Pld_set_mode::Create();
            (*cmd_set_mode)->target_system = vehicle.real_system_id;
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_guided_mode();
            cmd_messages.emplace_back(cmd_set_mode);
        }

        heading = vehicle_command_request->Get_heading();

        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        if (ardu_vehicle.Get_type() == Type::PLANE) {
            (*param)->param_id = "TRIM_ARSPD_CM";
            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT32;
            (*param)->param_value = vehicle_command_request->Get_speed() * 100;
            cmd_messages.emplace_back(param);
        } else if (ardu_vehicle.Get_type() == Type::COPTER) {
            (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
            (*cmd_long)->param1 = vehicle_command_request->Get_speed();
            (*cmd_long)->param2 = vehicle_command_request->Get_speed();
            cmd_messages.emplace_back(cmd_long);

            (*param)->param_id = "WPNAV_SPEED";
            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            (*param)->param_value = vehicle_command_request->Get_speed() * 100;
            cmd_messages.emplace_back(param);

            if (!std::isnan(heading)) {
                // we have heading specified. turn first.
                cmd_mission_item = mavlink::Pld_mission_item::Create();
                Fill_target_ids(*cmd_mission_item);
                (*cmd_mission_item)->current = 2;
                (*cmd_mission_item)->frame = mavlink::MAV_FRAME_GLOBAL_RELATIVE_ALT;
                (*cmd_mission_item)->autocontinue = 1;
                (*cmd_mission_item)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
                // yaw angle
                (*cmd_mission_item)->param1 = heading * 180.0 / M_PI;
                // Use default angular speed (AUTO_YAW_SLEW_RATE == 60 deg/s)
                (*cmd_mission_item)->param2 = 0;
                // absolute angle
                (*cmd_mission_item)->param4 = 0;
                cmd_messages.emplace_back(cmd_mission_item);
            }
        }

        cmd_mission_item = mavlink::Pld_mission_item::Create();
        Fill_target_ids(*cmd_mission_item);
        (*cmd_mission_item)->current = 2;
        (*cmd_mission_item)->frame = mavlink::MAV_FRAME_GLOBAL_RELATIVE_ALT;
        (*cmd_mission_item)->autocontinue = 1;
        (*cmd_mission_item)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
        (*cmd_mission_item)->param1 = 0; // hold time
        (*cmd_mission_item)->param2 = vehicle_command_request->Get_acceptance_radius(); // acct radius
        (*cmd_mission_item)->param3 = 0; // passby radius
        (*cmd_mission_item)->param4 = heading * 180.0 / M_PI; // yaw angle
        (*cmd_mission_item)->x = vehicle_command_request->Get_latitude() * 180.0 / M_PI;
        (*cmd_mission_item)->y = vehicle_command_request->Get_longitude() * 180.0 / M_PI;
        (*cmd_mission_item)->z = vehicle_command_request->Get_altitude() - vehicle_command_request->Get_takeoff_altitude();
        cmd_messages.emplace_back(cmd_mission_item);
        break;

    case Vehicle_command::Type::LAND:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
        cmd_messages.emplace_back(cmd_long);
        break;

    case Vehicle_command::Type::JOYSTICK_CONTROL_MODE:
        if (current_control_mode == Sys_status::Control_mode::JOYSTICK) {
            vehicle_command_request.Succeed();
        } else {
            // Set vehicle in manual mode and start pushing RC_CHANNELS_OVERRIDE messages.
            cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
            Fill_target_system_id(*cmd_set_mode);
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
            cmd_messages.emplace_back(cmd_set_mode);
        }
        ardu_vehicle.Start_rc_override();
        break;

    case Vehicle_command::Type::DIRECT_VEHICLE_CONTROL:
//        LOG("Direct Vehicle (rpyt) %1.3f %1.3f %1.3f %1.3f",
//            vehicle_command_request->Get_roll(),
//            vehicle_command_request->Get_pitch(),
//            vehicle_command_request->Get_yaw(),
//            vehicle_command_request->Get_throttle()
//            );
        if (current_control_mode != Sys_status::Control_mode::JOYSTICK) {
            break;
        }
        ardu_vehicle.direct_vehicle_control_last_received = std::chrono::steady_clock::now();
        pitch = vehicle_command_request->Get_pitch();
        yaw = vehicle_command_request->Get_yaw();

        // Normalize axes depending on vehicle type.
        if (ardu_vehicle.Get_type() == Type::COPTER) {
            pitch = -pitch;         // pitch is reversed for copter.
            yaw = yaw * 0.4;    // yaw on copter is too sensitive.
        } else {
            yaw = -yaw;     // yaw is reversed for plane.
        }

        ardu_vehicle.Set_rc_override(
            (vehicle_command_request->Get_roll() * 500.0) + 1500,
            (pitch * 500.0) + 1500,
            (vehicle_command_request->Get_throttle() * 500.0) + 1500,
            (yaw * 500.0) + 1500);
        ardu_vehicle.Send_rc_override();
        break;

    case Vehicle_command::Type::DIRECT_PAYLOAD_CONTROL:
//        LOG("Direct Payload %d (rpyz) %1.3f %1.3f %1.3f %1.3f",
//            vehicle_command_request->Get_payload_id(),
//            vehicle_command_request->Get_roll(),
//            vehicle_command_request->Get_pitch(),
//            vehicle_command_request->Get_yaw(),
//            vehicle_command_request->Get_zoom()
//            );
        break;

    case Vehicle_command::Type::RETURN_HOME:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH;
        cmd_messages.emplace_back(cmd_long);
        break;

    default:
        break;
    }

    if (cmd_messages.size()) {
        Send_message(*(cmd_messages.front()));
        Schedule_timer();
        VEHICLE_LOG_DBG(vehicle, "Sending to vehicle: %s", (*(cmd_messages.front())).Dump().c_str());
    } else {
        // Command list is empty, nothing to do.
        Disable();
    }

    return false;
}

void
Ardupilot_vehicle::Start_rc_override()
{
    if (rc_override == nullptr) {
        // Create rc_override message. timer will delete it when vehicle switched to other mode.
        rc_override = mavlink::Pld_rc_channels_override::Create();
        rc_override_timer = Timer_processor::Get_instance()->Create_timer(
            RC_OVERRIDE_PERIOD,
            Make_callback(&Ardupilot_vehicle::Send_rc_override_timer, Shared_from_this()),
            Get_completion_ctx());
    }
    rc_override_end_counter = RC_OVERRIDE_END_COUNT;
    // Set larger timeout when turning on joystick mode
    // to let client more time to understand that joystick commands must be sent, now.
    direct_vehicle_control_last_received =
        std::chrono::steady_clock::now() + RC_OVERRIDE_TIMEOUT;
    Set_rc_override(1500, 1500, 1500, 1500);
}

void
Ardupilot_vehicle::Set_rc_override(int p, int r, int t, int y)
{
    if (Is_rc_override_active()) {
        (*rc_override)->chan1_raw = p;
        (*rc_override)->chan2_raw = r;
        (*rc_override)->chan3_raw = t;
        (*rc_override)->chan4_raw = y;
    }
}

void
Ardupilot_vehicle::Stop_rc_override()
{
    if (Is_rc_override_active()) {
        Set_rc_override(0, 0, 0, 0);
        // initiate countdown
        rc_override_end_counter = RC_OVERRIDE_END_COUNT - 1;
    }
}

void
Ardupilot_vehicle::Send_rc_override()
{
    // Do not send
    if (rc_override) {
//        LOG("Direct vehicle %d %d %d %d",
//            (*rc_override)->chan1_raw.Get(),
//            (*rc_override)->chan2_raw.Get(),
//            (*rc_override)->chan3_raw.Get(),
//            (*rc_override)->chan4_raw.Get()
//            );
        mav_stream->Send_message(
                *rc_override,
                255,
                190,
                Mavlink_vehicle::WRITE_TIMEOUT,
                Make_timeout_callback(
                        &Mavlink_vehicle::Write_to_vehicle_timed_out,
                        Shared_from_this(),
                        mav_stream),
                Get_completion_ctx());

        rc_override_last_sent = std::chrono::steady_clock::now();
        if (rc_override_end_counter < RC_OVERRIDE_END_COUNT && rc_override_end_counter > 0) {
            rc_override_end_counter--;
        }
    }
}

bool
Ardupilot_vehicle::Is_rc_override_active()
{
    return (rc_override && rc_override_end_counter == RC_OVERRIDE_END_COUNT);
}

bool
Ardupilot_vehicle::Send_rc_override_timer()
{
    if (rc_override == nullptr) {
        return false;
    }

    auto now = std::chrono::steady_clock::now();

    if (now - direct_vehicle_control_last_received > RC_OVERRIDE_TIMEOUT) {
        // Automatically exit joystick mode if there are no control messages from ucs.
        Stop_rc_override();
    }

    if (now - rc_override_last_sent < RC_OVERRIDE_PERIOD) {
        // Do not spam radio link too much.
        return true;
    }

    Send_rc_override();

    if (rc_override_end_counter == 0) {
        // exiting joystick mode.
        rc_override = nullptr;
        return false;
    }
    return true;
}

void
Ardupilot_vehicle::Vehicle_command_act::Send_next_command()
{
    cmd_messages.pop_front();
    if (cmd_messages.size()) {
        // send next command in chain.
        remaining_attempts = ATTEMPTS;
        Send_message(*(cmd_messages.front()));
        Schedule_timer();
        VEHICLE_LOG_DBG(vehicle, "Sending to vehicle: %s", (*(cmd_messages.front())).Dump().c_str());
    } else {
        // command chain succeeded.
        vehicle_command_request.Succeed();
        Disable();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_command_ack(
        mavlink::Message<mavlink::MESSAGE_ID::COMMAND_ACK>::Ptr message)
{
    VEHICLE_LOG_DBG(vehicle, "COMAMND_ACK for command %d, res=%d",
            message->payload->command.Get(), message->payload->result.Get());

    if (cmd_messages.size()) {
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        int command_id = cmd->Get_id();
        if (command_id == mavlink::MESSAGE_ID::COMMAND_LONG) {
            command_id = (*std::static_pointer_cast<mavlink::Pld_command_long>(cmd))->command.Get();
        }
        if (message->payload->command.Get() == command_id) {
            // This is a response to our command.
            if (message->payload->result == mavlink::MAV_RESULT::MAV_RESULT_ACCEPTED) {
                Send_next_command();
            } else {
                auto p = message->payload->result.Get();
                vehicle_command_request.Fail("Result: %d (%s)", p, Mav_result_to_string(p).c_str());
                Disable();
            }
        } else {
            VEHICLE_LOG_ERR(vehicle, "Unexpected command acked. Expected: %d", command_id);
        }
    } else {
        // We are not waiting for messages.
        VEHICLE_LOG_ERR(vehicle, "Unexpected COMAMND_ACK");
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_mission_ack(
        mavlink::Message<mavlink::MESSAGE_ID::MISSION_ACK>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "MISSION_ACK, result %d",
            message->payload->type.Get());

    if (cmd_messages.size()) {
        if (message->payload->type == mavlink::MAV_MISSION_RESULT::MAV_MISSION_ACCEPTED) {
            Send_next_command();
        } else {
            auto p = message->payload->type.Get();
            vehicle_command_request.Fail(
                "Result: %d (%s)",
                p,
                Mav_mission_result_to_string(p).c_str());
            Disable();
        }
    } else {
        // We are not waiting for messages.
        vehicle_command_request.Fail("Unexpected MISSION_ACK");
        Disable();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_param_value(
        mavlink::Message<mavlink::MESSAGE_ID::PARAM_VALUE>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "PARAM_VALUE, %s", message->payload.Dump().c_str());

    if (cmd_messages.size()) {
        std::string param_name;
        mavlink::Float param_value;
        bool is_success = false;
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        switch (cmd->Get_id()) {
        case mavlink::MESSAGE_ID::PARAM_REQUEST_READ:
            param_name = (*std::static_pointer_cast<mavlink::Pld_param_request_read>(cmd))->param_id.Get_string();
            is_success = message->payload->param_id.Get_string() == param_name;
            if (is_success) {
                Send_next_command();
            } else {
                vehicle_command_request.Fail("PARAM_REQUEST_READ failed");
                Disable();
            }
            break;
        case mavlink::MESSAGE_ID::PARAM_SET:
            param_name = (*std::static_pointer_cast<mavlink::Pld_param_set>(cmd))->param_id.Get_string();
            param_value = (*std::static_pointer_cast<mavlink::Pld_param_set>(cmd))->param_value.Get();
            is_success =
                message->payload->param_id.Get_string() == param_name
                &&  message->payload->param_value.Get() == param_value;
            if (is_success) {
                Send_next_command();
            } else {
                vehicle_command_request.Fail("PARAM_SET failed");
                Disable();
            }
            break;
        }
    } else {
        // We are not waiting for messages.
        vehicle_command_request.Fail("Unexpected PARAM_VALUE");
        Disable();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_status_text(
        ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::STATUSTEXT>::Ptr)
{
    /* Assumed command execution started, so wait longer. */
    if (current_timeout != RETRY_TIMEOUT_LONG) {
        current_timeout = RETRY_TIMEOUT_LONG;
        VEHICLE_LOG_DBG(vehicle, "Command execution detected, "
                "now waiting longer for a command to finish...");
        /* Start a new longer timer. */
        Schedule_timer();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::Enable(
        Vehicle_command_request::Handle vehicle_command_request)
{
    if (ardu_vehicle.Get_type() == Type::OTHER) {
        /* Commands for unknown vehicles types are not supported. */
        Disable();
        return;
    }

    try {
        Register_mavlink_handler<mavlink::MESSAGE_ID::COMMAND_ACK>(
            &Vehicle_command_act::On_command_ack,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);

        Register_mavlink_handler<mavlink::MESSAGE_ID::MISSION_ACK>(
            &Vehicle_command_act::On_mission_ack,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);

        Register_mavlink_handler<mavlink::MESSAGE_ID::PARAM_VALUE>(
            &Vehicle_command_act::On_param_value,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);
    } catch (const Mavlink_demuxer::Duplicate_handler& e) {
        vehicle_command_request.Fail("Another command in progress");
        Disable();
        return;
    }

    this->vehicle_command_request = vehicle_command_request;

    remaining_attempts = ATTEMPTS;
    Try();
}

void
Ardupilot_vehicle::Vehicle_command_act::On_disable()
{
    Unregister_mavlink_handlers();
    Unregister_status_text();

    if (timer) {
        timer->Cancel();
        timer = nullptr;
    }

    vehicle_command_request.Fail();
}

void
Ardupilot_vehicle::Vehicle_command_act::Schedule_timer()
{
    if (timer) {
        timer->Cancel();
    }
    timer = Timer_processor::Get_instance()->Create_timer(
                std::chrono::seconds(current_timeout),
                Make_callback(&Vehicle_command_act::Try, this),
                vehicle.Get_completion_ctx());
}

void
Ardupilot_vehicle::Vehicle_command_act::Register_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Make_statustext_handler(
                    &Ardupilot_vehicle::Vehicle_command_act::On_status_text,
                    this);
}

void
Ardupilot_vehicle::Vehicle_command_act::Unregister_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Statustext_handler();
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_auto_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::AUTO);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::AUTO);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::AUTO);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom auto mode.", ardu_vehicle.Get_type());
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_manual_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::LOITER);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::STABILIZE);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::MANUAL);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom manual mode.", ardu_vehicle.Get_type());
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_guided_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::GUIDED);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::GUIDED);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::GUIDED);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom manual mode.", ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Enable(
        Vehicle_task_request::Handle request)
{
    this->request = request;

    if (ardu_vehicle.send_home_position_as_mav_cmd) {
        // HL altitude becomes altitude origin.
        // Need to set at the very beginning as it is used to specify safe_altitude, too.
        request->Set_takeoff_altitude(request->Get_home_position_altitude());
    }

    Filter_actions();
    Prepare_task_attributes();

    vehicle.write_parameters.Disable();
    vehicle.write_parameters.Set_next_action(
            Write_parameters::Make_next_action(
                    &Task_upload::Task_atributes_uploaded,
                    this));
    vehicle.write_parameters.Enable(task_attributes);
}


void
Ardupilot_vehicle::Task_upload::Task_atributes_uploaded(bool success, std::string error_msg)
{
    if (!success) {
        if (error_msg.size()) {
            request.Fail(error_msg);
        } else {
            request.Fail("Task attributes upload failed");
        }
        Disable();
        return;
    }

    if (ardu_vehicle.send_home_position_as_mav_cmd) {
        vehicle.do_commands.Disable();
        vehicle.do_commands.Set_next_action(
                Activity::Make_next_action(
                        &Task_upload::Task_commands_sent,
                        this));

        mavlink::Pld_command_long cmd;
        auto hl = request->Get_home_position().Get_geodetic();
        cmd->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
        cmd->param1 = 0; // use specified.
        cmd->param5 = hl.latitude * 180 / M_PI;
        cmd->param6 = hl.longitude * 180 / M_PI;
        cmd->param7 = hl.altitude;
        vehicle.do_commands.Enable({cmd});
    } else {
        Task_commands_sent(true);
    }
}

void
Ardupilot_vehicle::Task_upload::Task_commands_sent(bool success, std::string)
{
    if (!success) {
        request.Fail("Failed to set home location");
        Disable();
        return;
    }

    // New home location should be set by now.
    // invalidate current home location and timer handler will retrieve it again.
    ardu_vehicle.home_location.longitude = 0;
    ardu_vehicle.home_location.latitude = 0;

    Prepare_task();
    vehicle.mission_upload.Disable();
    vehicle.mission_upload.mission_items = std::move(prepared_actions);
    vehicle.mission_upload.Set_next_action(
            Activity::Make_next_action(
                    &Task_upload::Mission_uploaded,
                    this));
    vehicle.mission_upload.Enable();

}

void
Ardupilot_vehicle::Task_upload::Mission_uploaded(bool success, std::string error_msg)
{
    if (!success) {
        if (error_msg.size()) {
            request.Fail(error_msg);
        } else {
            request.Fail("Route upload failed");
        }
        Disable();
        return;
    }
    /* Everything is OK. */
    request.Succeed();
    Disable();
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_coords(
        mavlink::Pld_mission_item& msg,
        const Geodetic_tuple& tuple, double heading)
{
    msg->x = (tuple.latitude * 180.0) / M_PI;
    msg->y = (tuple.longitude * 180.0) / M_PI;
    /* Fixup absolute altitude - make them relative to
     * take-off altitude.
     */
    msg->z = tuple.altitude - request->Get_takeoff_altitude();
    msg->param4 = (heading * 180.0) / M_PI;
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_common(
        mavlink::Pld_mission_item& msg)
{
    ASSERT(vehicle.real_system_id != Mavlink_demuxer::SYSTEM_ID_ANY);

    Fill_target_ids(msg);
    msg->seq = prepared_actions.size();
    /* APM firmware treats all altitudes as relative. Always. */
    msg->frame = mavlink::MAV_FRAME::MAV_FRAME_GLOBAL_RELATIVE_ALT;
    msg->current = 0;
    msg->autocontinue = 1;
}

void
Ardupilot_vehicle::Task_upload::On_disable()
{
    request.Fail("Upload canceled");
    vehicle.write_parameters.Disable();
    vehicle.mission_upload.Disable();
    prepared_actions.clear();
    task_attributes.clear();
    current_mission_poi.Disengage();
    current_mission_heading.Disengage();
    last_move_action = nullptr;
    first_mission_poi_set = false;
    restart_mission_poi = false;
    current_heading = 0;
    heading_to_this_wp = 0;
}

void
Ardupilot_vehicle::Task_upload::Filter_actions()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Filter_copter_actions();
        return;
    case Type::PLANE:
        Filter_plane_actions();
        return;
    case Type::ROVER:
        Filter_rover_actions();
        return;
    case Type::OTHER:
        Filter_other_actions();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d.",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Filter_copter_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_plane_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_rover_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_other_actions()
{
    /* Only move is supported. Safe. */
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::MOVE:
            iter++;
            continue;
        default:
            VEHICLE_LOG_WRN(vehicle, "Action type %d ignored.", static_cast<int>((*iter)->Get_type()));
            break;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task()
{
    prepared_actions.clear();

    /* Ardupilot waypoint at index zero is always treated as home position,
     * so ensure it is always present. In other words, real waypoint should not
     * be stored at zero index.
     */
    Set_home_action::Ptr set_home_action = Set_home_action::Create(
            false /* use specified. */,
            request->Get_home_position(),
            0 /* elevation. */);

    Prepare_action(set_home_action);

    bool first_set_home_found = false;
    bool takeoff_added = false;

    last_move_action = nullptr;
    for (auto& iter:request->actions) {
        switch (iter->Get_type()) {
        case Action::Type::TAKEOFF:
            takeoff_added = true;
            break;
        case Action::Type::MOVE:
            if (!takeoff_added) {
                // First WP found without prior takeoff action.
                // Insert takeoff action on first WP.
                // Required for ArduCopter 3.4+ otherwise it fails AUTO command.
                auto to = iter->Get_action<Action::Type::MOVE>();
                VEHICLE_LOG_WRN(vehicle, "Auto-adding TAKEOFF action before 1st WP");
                mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
                (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_TAKEOFF;
                (*mi)->param1 = 0; /* No data for pitch. */
                Fill_mavlink_mission_item_coords(*mi, to->position.Get_geodetic(), to->heading);
                Add_mission_item(mi);
                takeoff_added = true;
            }
            break;
        case Action::Type::SET_HOME:
            if (!first_set_home_found) {
                /* Skip first set_home, it has been already processed and put
                 * into waypoint index zero. */
                first_set_home_found = true;
                continue;
            }
            break;
        default:
            break;
        }
        Prepare_action(iter);
    }

    if (last_move_action) {
        Prepare_action(last_move_action);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task_attributes()
{
    task_attributes.clear();
    if (request->attributes == nullptr) {
        return;
    }
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Prepare_copter_task_attributes();
        return;
    case Type::PLANE:
        Prepare_plane_task_attributes();
        return;
    case Type::ROVER:
        Prepare_rover_task_attributes();
        return;
    case Type::OTHER:
        Prepare_other_task_attributes();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Prepare_copter_task_attributes()
{
    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    using Emerg = Task_attributes_action::Emergency_action;

    /* Battery failsafe. */
    param->param_id = "FS_BATT_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->low_battery) {
    case Emerg::GO_HOME:
        param->param_value = 2;
        break;
    case Emerg::LAND:
        param->param_value = 1;
        break;
    case Emerg::WAIT:
        /* There is no support for such behavior. Override with land. */
        param->param_value = 1;
        break;
    case Emerg::CONTINUE:
        param->param_value = 0;
        break;
    }
    task_attributes.push_back(param);

    /* GNSS loss failsafe. */
    if (ardu_vehicle.use_ekf_action_as_gps_failsafe) {
        param->param_id = "FS_EKF_ACTION";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        switch (request->attributes->gnss_loss) {
        case Emerg::LAND:
            param->param_value = 1;
            break;
        case Emerg::WAIT:
            param->param_value = 2;
            break;
        default:
            LOG_WARN("Invalid FS action for GPS");
            break;
        }
    } else {
        param->param_id = "FS_GPS_ENABLE";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        switch (request->attributes->gnss_loss) {
        case Emerg::LAND:
            param->param_value = 3;
            break;
        case Emerg::WAIT:
            param->param_value = 2;
            break;
        default:
            LOG_WARN("Invalid FS action for GPS");
            break;
        }
    }
    task_attributes.push_back(param);

    /* Radio Control loss failsafe. */
    param->param_id = "FS_THR_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->rc_loss) {
    case Emerg::GO_HOME:
        param->param_value = 1;
        break;
    case Emerg::LAND:
        param->param_value = 3;
        break;
    case Emerg::WAIT:
        /* Wait not supported, do land. */
        param->param_value = 3;
        break;
    case Emerg::CONTINUE:
        /* Continue in auto, land in other modes. */
        param->param_value = 2;
        break;
    }
    task_attributes.push_back(param);


    int16_t safe_alt = (request->attributes->safe_altitude - request->Get_takeoff_altitude()) * 100;

    if (safe_alt < 100) {
        // Avoid landing.
        VEHICLE_LOG_WRN(vehicle, "Forcing safe altitude to 1m");
        safe_alt = 100;
    }
    /* RTL altitude. */
    param->param_id = "RTL_ALT";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
    param->param_value = safe_alt;
    task_attributes.push_back(param);

    /* RTL Final altitude. Set to the same as RTL_ALT.
     * This makes it hover after RTL. 0 would mean land.*/
    param->param_id = "RTL_ALT_FINAL";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
    param->param_value = safe_alt;
    task_attributes.push_back(param);

    /* Don't change yaw during auto mission, because there is an auto-POI
     * feature. Besides that, duplicated waypoints are used to implement
     * actions like panorama, so it is not desirable to change the yaw while
     * switching between waypoints sharing the same location. */
    param->param_id = "WP_YAW_BEHAVIOR";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Never change yaw. */
    task_attributes.push_back(param);

#if 0 /* Wait until supported. */
    /* Mount control mode. */
    param->param_id = "MNT_MODE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 2; /* Mavlink targeting. */
    task_attributes.push_back(param);
#endif

    param->param_id = "CAM_TRIGG_TYPE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Servo trigger type. */
    task_attributes.push_back(param);
}

void
Ardupilot_vehicle::Task_upload::Prepare_plane_task_attributes()
{
    /* Add plane specific task attributes */
    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    float v;    // All my parameters are float.
    for (auto & p : request->parameters) {
        if (p.second->Get_value(v)) {
            if        (p.first == "landing_flare_altitude") {
                param->param_id = "LAND_FLARE_ALT";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_flare_time") {
                param->param_id = "LAND_FLARE_SEC";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "min_landing_pitch") {
                param->param_id = "LAND_PITCH_CD";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
                param->param_value = static_cast<int16_t>(lround(v * 18000 / M_PI));
            } else if (p.first == "landing_flare_damp") {
                param->param_id = "TECS_LAND_DAMP";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_approach_airspeed") {
                param->param_id = "TECS_LAND_ARSPD";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_speed_weighting") {
                param->param_id = "TECS_LAND_SPDWGT";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "max_auto_flight_pitch") {
                param->param_id = "TECS_PITCH_MAX";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                param->param_value = static_cast<int8_t>(lround(v * 180 / M_PI));
            } else if (p.first == "max_pitch") {
                param->param_id = "LIM_PITCH_MAX";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
                param->param_value = static_cast<int16_t>(lround(v * 18000 / M_PI));
            } else if (p.first == "min_throttle") {
                param->param_id = "THR_MIN";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                param->param_value = static_cast<int8_t>(lround(v));
            } else if (p.first == "landing_sink_rate") {
                param->param_id = "TECS_LAND_SINK";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_rangefinder_enabled") {
                param->param_id = "RNGFND_LANDING";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                param->param_value = static_cast<int8_t>(lround(v));
            } else if (p.first == "min_rangefinder_distance") {
                param->param_id = "RNGFND_MIN_CM";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
                param->param_value = static_cast<int16_t>(lround(v * 100));
                param->param_value = v;
            } else {
                VEHICLE_LOG_WRN(vehicle, "Unsupported parameter %s received.", p.first.c_str());
            }
            task_attributes.push_back(param);
        } else {
            if (!p.second->Is_value_na()) {
                VEHICLE_LOG_WRN(vehicle, "Invalid value for parameter %s", p.first.c_str());
            }
        }
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_rover_task_attributes()
{
    /* Add rover specific task attributes */
}

void
Ardupilot_vehicle::Task_upload::Prepare_other_task_attributes()
{
    /* Stub. */
}

void
Ardupilot_vehicle::Task_upload::Prepare_action(Action::Ptr action)
{
    switch (action->Get_type()) {
    case Action::Type::MOVE:
        Prepare_move(action);
        return;
    case Action::Type::WAIT:
        Prepare_wait(action);
        return;
    case Action::Type::PAYLOAD_STEERING:
        Prepare_payload_steering(action);
        return;
    case Action::Type::TAKEOFF:
        Prepare_takeoff(action);
        return;
    case Action::Type::LANDING:
        Prepare_landing(action);
        return;
    case Action::Type::CHANGE_SPEED:
        Prepare_change_speed(action);
        return;
    case Action::Type::SET_HOME:
        Prepare_set_home(action);
        return;
    case Action::Type::POI:
        Prepare_POI(action);
        return;
    case Action::Type::HEADING:
        Prepare_heading(action);
        return;
    case Action::Type::PANORAMA:
        Prepare_panorama(action);
        return;
    case Action::Type::CAMERA_CONTROL:
        VSM_EXCEPTION(Internal_error_exception, "CAMERA_CONTROL action not supported.");
    case Action::Type::CAMERA_TRIGGER:
        Prepare_camera_trigger(action);
        return;
    case Action::Type::TASK_ATTRIBUTES:
        VSM_EXCEPTION(Internal_error_exception, "TASK_ATTRIBUTES action not supported.");
    case Action::Type::CAMERA_SERIES_BY_TIME:
        Prepare_camera_series_by_time(action);
        return;
    case Action::Type::CAMERA_SERIES_BY_DISTANCE:
        Prepare_camera_series_by_distance(action);
        return;
    case Action::Type::SET_PARAMETER:
        VSM_EXCEPTION(Internal_error_exception, "SET_PARAMETER action not supported.");
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unsupported action [%s]",
            action->Get_name().c_str());
}

void
Ardupilot_vehicle::Task_upload::Add_mission_item(mavlink::Pld_mission_item::Ptr mi)
{
    Fill_mavlink_mission_item_common(*mi);
    prepared_actions.push_back(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_move(Action::Ptr& action)
{
    /* Turn off camera series if active. */
    if (!camera_series_by_dist_active_in_wp) {
        if (camera_series_by_dist_active) {

            camera_series_by_dist_active = false;
            Camera_series_by_distance_action::Ptr a =
                action->Get_action<Action::Type::CAMERA_SERIES_BY_DISTANCE>();
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
            Add_mission_item(mi);
        }
    }
    if (!camera_series_by_time_active_in_wp) {
        if (camera_series_by_time_active) {
            camera_series_by_time_active = false;

            Camera_series_by_time_action::Ptr a =
                action->Get_action<Action::Type::CAMERA_SERIES_BY_TIME>();
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
            (*mi)->param1 = ardu_vehicle.camera_servo_idx;
            Add_mission_item(mi);
        }
    }
    camera_series_by_dist_active_in_wp = false;
    camera_series_by_time_active_in_wp = false;

    if (last_move_action) {
        auto from = last_move_action->Get_action<Action::Type::MOVE>();
        auto to = action->Get_action<Action::Type::MOVE>();
        float calculated_heading = from->position.Bearing(to->position);
        // Handle several waypoints at the same coords.
        if (!std::isnan(calculated_heading)) {
            calculated_heading = Normalize_angle_0_2pi(calculated_heading);
            heading_to_this_wp = calculated_heading;
        } else {
            // Use previously calculated heading_to_this_wp.
        }
    }

    if (current_mission_poi) {
        if (!first_mission_poi_set && (ardu_vehicle.auto_generate_mission_poi || restart_mission_poi)) {
            // Add automatic POI on each consecutive WP.
            LOG("Set AutoPOI");
            Add_mission_item(Build_roi_mission_item(*current_mission_poi));
        }
    } else {
        if (current_mission_heading) {
            // Set current heading as yaw angle.
            current_heading = *current_mission_heading;
        } else {
            // Set heading to next waypoint as yaw angle.
            current_heading = heading_to_this_wp;
        }
        if (last_move_action && ardu_vehicle.Get_type() == Type::COPTER) {
            // Autoheading is copter specific.
            LOG("Set Autoheading to %f", current_heading);
            Add_mission_item(Build_heading_mission_item(current_heading));
        }
    }

    Add_mission_item(Build_wp_mission_item(action));
    last_move_action = action;

    restart_mission_poi = false;
    first_mission_poi_set = false;
    current_mission_heading.Disengage();
}

void
Ardupilot_vehicle::Task_upload::Prepare_wait(Action::Ptr& action)
{
    /* Create additional waypoint on the current position to wait. */
    if (last_move_action) {
        first_mission_poi_set = false;
        restart_mission_poi = true;
        Wait_action::Ptr wa = action->Get_action<Action::Type::WAIT>();
        auto wp = Build_wp_mission_item(last_move_action);
        (*wp)->param1 = wa->wait_time;
        switch (ardu_vehicle.Get_type()) {
        case Type::COPTER:
            if (!current_mission_poi) {
                Add_mission_item(Build_heading_mission_item(
                        Normalize_angle_0_2pi(current_heading)));
            }
            Add_mission_item(wp);
            break;
        case Type::PLANE:
            (*wp)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LOITER_TIME;
            Add_mission_item(wp);
        default:
            VEHICLE_LOG_WRN(vehicle, "Wait supported only by plane and copter");
            break;
        }
    } else {
        VEHICLE_LOG_WRN(vehicle, "No move action before wait action, ignored.");
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_payload_steering(Action::Ptr&)
{
    ASSERT(false); /* Not implemented yet */
}

void
Ardupilot_vehicle::Task_upload::Prepare_takeoff(Action::Ptr& action)
{
    /* Ardupilot does not fly to the takeoff position after takeoff
     * is done. Add explicit waypoint after the takeoff command with
     * target coordinates.
     */
    auto takeoff = action->Get_action<Action::Type::TAKEOFF>();
    auto explicit_wp = Move_action::Create(
            takeoff->position,
            0,
            takeoff->acceptance_radius,
            0,
            takeoff->heading,
            takeoff->elevation
    );

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_TAKEOFF;
    (*mi)->param1 = 0; /* No data for pitch. */
    Fill_mavlink_mission_item_coords(*mi, takeoff->position.Get_geodetic(), takeoff->heading);
    Add_mission_item(mi);
    Prepare_action(explicit_wp);
}

void
Ardupilot_vehicle::Task_upload::Prepare_landing(Action::Ptr& action)
{
    /* Ardupilot does not take the altitude of the landing, so
     * add explicit waypoint guiding vehicle to the landing start
     * position.
     */
    auto land = action->Get_action<Action::Type::LANDING>();
    auto explicit_wp = Move_action::Create(
            land->position,
            0,
            land->acceptance_radius,
            0,
            land->heading,
            land->elevation
    );
    Prepare_action(explicit_wp);

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
    Fill_mavlink_mission_item_coords(*mi, land->position.Get_geodetic(), land->heading);
    Add_mission_item(mi);

    /* Don't duplicate waypoint if last action is land. */
    last_move_action = nullptr;
}

void
Ardupilot_vehicle::Task_upload::Prepare_change_speed(Action::Ptr& action)
{
    Change_speed_action::Ptr la = action->Get_action<Action::Type::CHANGE_SPEED>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
    auto speed = hypot(la->speed, la->vertical_speed);
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        /* ArduCopter version up to 3.2 use p1 for speed and ignores p2.
         * ArduCopter version up to 3.2+ use p2 for speed and ignores p1.
         * So, we set both, here.
         * Later, if MAV_CMD_DO_CHANGE_SPEED handling changes
         * in ArduPilot we will need to implement FW version checking.
         */
        (*mi)->param1 = speed;
        (*mi)->param2 = speed;
        break;
    case Type::ROVER:
    default:
        /* Ground rover takes only airspeed into account, others seems to
         * take both, but we have only airspeed from UCS, so use only air. */
        (*mi)->param1 = 0; /* Airspeed. */
        (*mi)->param2 = speed;
        break;
    }

    (*mi)->param3 = -1; /* Throttle no change. */
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_set_home(Action::Ptr& action)
{
    Set_home_action::Ptr sa = action->Get_action<Action::Type::SET_HOME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
    (*mi)->param1 = sa->use_current_position ? 1 : 0;
    Fill_mavlink_mission_item_coords(*mi, sa->home_position.Get_geodetic(), 0);
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_POI(Action::Ptr& action)
{
    Poi_action::Ptr pa = action->Get_action<Action::Type::POI>();
    if (pa->active) {
        // Set up POI for succeeding waypoints.
        current_mission_poi = pa->position.Get_geodetic();
        Add_mission_item(Build_roi_mission_item(*current_mission_poi));
        first_mission_poi_set = true;
    } else {
        // Reset POI. Generate next WPs as heading from now on.
        current_mission_poi.Disengage();
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_heading(Action::Ptr& action)
{
    Heading_action::Ptr ha = action->Get_action<Action::Type::HEADING>();
    Add_mission_item(Build_heading_mission_item(ha->heading));
    current_heading = ha->heading;
    current_mission_heading = ha->heading;
    // Heading action terminates current POI.
    restart_mission_poi = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_series_by_distance(Action::Ptr& action)
{
    Camera_series_by_distance_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_SERIES_BY_DISTANCE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
    (*mi)->param1 = a->interval;
    Add_mission_item(mi);
    camera_series_by_dist_active = true;
    camera_series_by_dist_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_series_by_time(Action::Ptr& action)
{
    Camera_series_by_time_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_SERIES_BY_TIME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    (*mi)->param3 = a->count ? *a->count : 0xffff;
    (*mi)->param4 = static_cast<float>(a->interval.count()) / 1000.0;
    Add_mission_item(mi);
    camera_series_by_time_active = true;
    camera_series_by_time_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_trigger(Action::Ptr& action)
{
    Camera_trigger_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_TRIGGER>();
    if (a->state != Camera_trigger_action::State::SINGLE_PHOTO &&
        a->state != Camera_trigger_action::State::SERIAL_PHOTO) {
        VEHICLE_LOG_WRN(vehicle, "Unsupported camera trigger state %d ignored.", a->state);
        return;
    }
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    if (a->state == Camera_trigger_action::State::SINGLE_PHOTO) {
        (*mi)->param3 = 1;
        (*mi)->param4 = ardu_vehicle.camera_servo_time;
    } else {
        (*mi)->param3 = 0xffff;
        (*mi)->param4 = static_cast<float>(a->interval.count()) / 1000.0;
        camera_series_by_time_active = true;
        camera_series_by_time_active_in_wp = true;
    }
    Add_mission_item(mi);
    camera_series_by_time_active = true;
    camera_series_by_time_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_panorama(Action::Ptr& action)
{
    Panorama_action::Ptr panorama = action->Get_action<Action::Type::PANORAMA>();

    if (!last_move_action) {
        VEHICLE_LOG_WRN(vehicle, "No previous move action found to generate panorama action, ignored.");
        return;
    }
//    LOG("Panorama angle=%f, speed=%f, step=%f, delay=%lu",
//            panorama->angle,
//            panorama->speed,
//            panorama->step,
//            panorama->delay.count()
//            );

    /* Panorama is always done in steps less then 180 degree to make sure that
     * turns over 180 degrees are supported.
     */
    double MAX_STEP = 3;
    double speed = std::abs(panorama->speed);
    if (speed == 0 || speed > 1) {
        speed = 1; /* 1 rad/second assumed max speed. */
    }

    float cur_angle = 0;
    float target_angle = std::abs(panorama->angle);
    float step = MAX_STEP;
    int delay = 0;
    // Set delay to slightly more than the calculated time.
    double panorama_duration = std::abs(panorama->angle) / speed + 3;

    switch (panorama->trigger_state) {
    case Panorama_action::Trigger_state::ON:
        break;
    case Panorama_action::Trigger_state::SERIAL:
        /* Per-sector delay. */
        delay = std::chrono::duration_cast<std::chrono::seconds>(panorama->delay).count();
        // non zero delay. Use step from action.
        step = std::abs(panorama->step);
        // Add some time the delay to make the turn.
        delay += step / speed + 2;
        // do not add the long pause waypoint at the end.
        panorama_duration = 0;
        break;
    }

    if (step == 0) {
        VEHICLE_LOG_WRN(vehicle, "Zero step angle, ignoring panorama.");
        return;
    }

    Add_mission_item(Build_heading_mission_item(current_heading));
    /* Create additional waypoint at the current position with wait to
     * stabilize before doing panorama. */
    auto waiter = Build_wp_mission_item(last_move_action);
    (*waiter)->param1 = 2; /* seconds. */
    Add_mission_item(waiter);

    // Set off the trigger
    Add_camera_trigger_item();

    while (cur_angle < target_angle) {
        if (cur_angle + step > target_angle) {
            step = target_angle - cur_angle;
        }

        float cur_step_angle = 0;
        while (cur_step_angle < step) {
            if (step > MAX_STEP) {
                cur_step_angle += MAX_STEP;
            } else {
                cur_step_angle += step;
            }
            if (cur_step_angle > step) {
                cur_step_angle = step;
            }
            float temp_heading = cur_angle + cur_step_angle;
            if (panorama->angle < 0) {
                temp_heading = -temp_heading;
            }
            Add_mission_item(Build_heading_mission_item(
                    Normalize_angle_0_2pi(current_heading + temp_heading),
                    speed));
        }
        if (delay) {
            waiter = Build_wp_mission_item(last_move_action);
            (*waiter)->param1 = delay;
            Add_mission_item(waiter);

            // Set off trigger
            Add_camera_trigger_item();
        }
        cur_angle += cur_step_angle;
    }
    if (panorama->angle > 0) {
        current_heading = Normalize_angle_0_2pi(current_heading + target_angle);
    } else {
        current_heading = Normalize_angle_0_2pi(current_heading - target_angle);
    }


    /* Create a waypoint with hold time slightly more than estimated
     * panorama duration. Used only with Trigger_state::ON.
     */
    if (panorama_duration) {
        VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is %f seconds.", panorama_duration);
        auto long_wait = Build_wp_mission_item(last_move_action);
        if (panorama_duration > 255) {
            VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is truncated to 255 seconds.");
            (*long_wait)->param1 = 255; /* Max possible wait for Ardupilot. */
        } else {
            (*long_wait)->param1 = panorama_duration;
        }
        Add_mission_item(long_wait);
        LOG("long_wait WP %f", panorama_duration);
    }
    // panorama action terminates current POI.
    restart_mission_poi = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_control(Action::Ptr& action)
{
    Camera_control_action::Ptr cam_control =
            action->Get_action<Action::Type::CAMERA_CONTROL>();

    /* TODO wait until supported by Ardupilot. */
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL;
    Add_mission_item(mi);
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_heading_mission_item(
        float heading,
        float speed,
        bool absolute_angle,
        bool clockwise
        )
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
    (*mi)->param1 = (Normalize_angle_0_2pi(heading) * 180.0) / M_PI;
    (*mi)->param2 = (speed * 180) / M_PI;
    (*mi)->param3 = clockwise? 1: -1;       // Not implemented in AP.
    (*mi)->param4 = absolute_angle? 0: 1;   /* absolute angle. */
    return mi;
}

void
Ardupilot_vehicle::Task_upload::Add_camera_trigger_item()
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    (*mi)->param3 = 1;
    (*mi)->param4 = ardu_vehicle.camera_servo_time;
    Add_mission_item(mi);
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_roi_mission_item(const Geodetic_tuple& coords)
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_ROI;
    if (coords.latitude == 0 && coords.longitude == 0 && coords.altitude == 0)
    {
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_NONE;
    } else {
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_LOCATION;
    }
    Fill_mavlink_mission_item_coords(*mi, coords, 0);
    return mi;
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_wp_mission_item(Action::Ptr& action)
{
    Move_action::Ptr ma = action->Get_action<Action::Type::MOVE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();

    if (ardu_vehicle.Get_type() == Type::COPTER) {
        switch (ma->turn_type) {
        case Move_action::TURN_TYPE_SPLINE:
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT;
            break;
        default:
            VEHICLE_LOG_WRN(vehicle, "Invalid turn type: %d, defaulting to 'straight'.", ma->turn_type);
        case Move_action::TURN_TYPE_STRAIGHT:
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
            break;
        }
    } else {
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
    }
    (*mi)->param1 = ma->wait_time;
    /* Set acceptance radius to something reasonable. */
    if (ma->acceptance_radius < ACCEPTANCE_RADIUS_MIN) {
        (*mi)->param2 = ACCEPTANCE_RADIUS_MIN;
        VEHICLE_LOG_INF(vehicle, "Acceptance radius normalized from %f to %f",
                ma->acceptance_radius, (*mi)->param2.Get());
    } else {
        (*mi)->param2 = ma->acceptance_radius;
    }
    (*mi)->param3 = ma->loiter_orbit;
    Fill_mavlink_mission_item_coords(*mi, ma->position.Get_geodetic(), ma->heading);
    return mi;
}

void
Ardupilot_vehicle::Process_heartbeat(
            ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::HEARTBEAT>::Ptr message)
{
    Sys_status::Control_mode control_mode = Sys_status::Control_mode::UNKNOWN;
    auto new_mode = static_cast<Copter_flight_mode>(message->payload->custom_mode.Get());
    switch (Get_type()) {
    case Type::COPTER:
        if (new_mode != current_copter_flight_mode) {
            LOG(
                "Copter mode changed from %d to %d",
                static_cast<int>(current_copter_flight_mode),
                static_cast<int>(new_mode));
        }
        current_copter_flight_mode = new_mode;
        control_mode = Map_copter_flight_mode(current_copter_flight_mode);
        break;
    case Type::ROVER:
        control_mode = Map_rover_flight_mode(static_cast<Rover_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::PLANE:
        control_mode = Map_plane_flight_mode(static_cast<Plane_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::OTHER:;
    }

    Sys_status::State state = Sys_status::State::DISARMED;
    if (message->payload->base_mode.Get() & mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED) {
        state = Sys_status::State::ARMED;
    }

    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - recent_connect);

    Update_capabilities();
    Update_capability_states();
    Set_system_status(Sys_status(true, true, control_mode, state, uptime));
}

void
Ardupilot_vehicle::Get_home_location()
{
    read_waypoints.Disable();
    read_waypoints.Get_home_location();
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_copter_flight_mode(Copter_flight_mode custom_mode)
{

    switch (custom_mode) {
    case Copter_flight_mode::GUIDED:
        return Sys_status::Control_mode::GUIDED;
    case Copter_flight_mode::AUTO:
    case Copter_flight_mode::RTL:
    case Copter_flight_mode::CIRCLE:
    case Copter_flight_mode::LAND:
    case Copter_flight_mode::AUTOTUNE:
        return Sys_status::Control_mode::AUTO;
    case Copter_flight_mode::STABILIZE:
    case Copter_flight_mode::ACRO:
    case Copter_flight_mode::ALT_HOLD:
    case Copter_flight_mode::OF_LOITER:
    case Copter_flight_mode::LOITER:
    case Copter_flight_mode::DRIFT:
    case Copter_flight_mode::SPORT:
    case Copter_flight_mode::FLIP:
        if (Is_rc_override_active()) {
            return Sys_status::Control_mode::JOYSTICK;
        } else {
            return Sys_status::Control_mode::MANUAL;
        }
    }
    return Sys_status::Control_mode::UNKNOWN;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_plane_flight_mode(Plane_flight_mode custom_mode)
{
    switch (custom_mode) {
    case Plane_flight_mode::AUTO:
    case Plane_flight_mode::LOITER:
    case Plane_flight_mode::CIRCLE:
    case Plane_flight_mode::RTL:
        return Sys_status::Control_mode::AUTO;
    case Plane_flight_mode::GUIDED:
        return Sys_status::Control_mode::GUIDED;
    case Plane_flight_mode::MANUAL:
    case Plane_flight_mode::STABILIZE:
    case Plane_flight_mode::TRAINING:
    case Plane_flight_mode::ACRO:
    case Plane_flight_mode::FLY_BY_WIRE_A:
    case Plane_flight_mode::FLY_BY_WIRE_B:
    case Plane_flight_mode::CRUISE:
        if (Is_rc_override_active()) {
            return Sys_status::Control_mode::JOYSTICK;
        } else {
            return Sys_status::Control_mode::MANUAL;
        }
    case Plane_flight_mode::INITIALISING:;
        /* Fall down to unknown. */
    }

    return Sys_status::Control_mode::UNKNOWN;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_rover_flight_mode(Rover_flight_mode custom_mode)
{
    switch (custom_mode) {
    case Rover_flight_mode::AUTO:
    case Rover_flight_mode::RTL:
        return Sys_status::Control_mode::AUTO;
    case Rover_flight_mode::GUIDED:
        return Sys_status::Control_mode::GUIDED;
    case Rover_flight_mode::MANUAL:
    case Rover_flight_mode::LEARNING:
    case Rover_flight_mode::STEERING:
    case Rover_flight_mode::HOLD:
        if (Is_rc_override_active()) {
            return Sys_status::Control_mode::JOYSTICK;
        } else {
            return Sys_status::Control_mode::MANUAL;
        }
    case Rover_flight_mode::INITIALISING:;
    /* Fall down to unknown. */
    }

    return Sys_status::Control_mode::UNKNOWN;
}

void
Ardupilot_vehicle::Update_capabilities()
{
    // Common capabilities to fixed and multicopter.
    auto capas = Capabilities(
            Vehicle::Capability::ARM_AVAILABLE,
            Vehicle::Capability::DISARM_AVAILABLE,
            Vehicle::Capability::WAYPOINT_AVAILABLE,
            Vehicle::Capability::AUTO_MODE_AVAILABLE,
            Vehicle::Capability::GUIDED_MODE_AVAILABLE,
            Vehicle::Capability::MANUAL_MODE_AVAILABLE,
            Vehicle::Capability::PAUSE_MISSION_AVAILABLE,
            Vehicle::Capability::RESUME_MISSION_AVAILABLE,
            Vehicle::Capability::RETURN_HOME_AVAILABLE);

    switch (Get_type()) {
    case Type::COPTER:
        // Copter has LAND and sometimes -- joystick.
        capas.Set(Vehicle::Capability::LAND_AVAILABLE, true);
        capas.Set(Vehicle::Capability::JOYSTICK_MODE_AVAILABLE, true);
        if (Get_system_status().control_mode == Sys_status::Control_mode::JOYSTICK) {
            capas.Set(Vehicle::Capability::DIRECT_VEHICLE_CONTROL_AVAILABLE, true);
        }
        Set_capabilities(capas);
        return;

    case Type::PLANE:
        if (enable_joystick_control_for_fixed_wing) {
            capas.Set(Vehicle::Capability::JOYSTICK_MODE_AVAILABLE, true);
            if (Get_system_status().control_mode == Sys_status::Control_mode::JOYSTICK)
            {
                capas.Set(Vehicle::Capability::DIRECT_VEHICLE_CONTROL_AVAILABLE, true);
            }
        }
        Set_capabilities(capas);
        return;

    case Type::ROVER:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::OTHER:;
    }
    /* Others don't support anything. */
    Set_capabilities(Capabilities());
}

void
Ardupilot_vehicle::Configure()
{
    auto props = ugcs::vsm::Properties::Get_instance().get();
    camera_servo_idx = props->Get_int("vehicle.ardupilot.camera_servo_idx");
    camera_servo_pwm = props->Get_int("vehicle.ardupilot.camera_servo_pwm");
    camera_servo_time = props->Get_float("vehicle.ardupilot.camera_servo_time");
    if (props->Exists("vehicle.ardupilot.enable_joystick_control_for_fixed_wing")) {
        auto yes = props->Get("vehicle.ardupilot.enable_joystick_control_for_fixed_wing");
        if (yes == "yes") {
            LOG_INFO("Enabled joystick mode for fixed wing.");
            enable_joystick_control_for_fixed_wing = true;
        }
    }
    if (props->Exists("vehicle.ardupilot.report_relative_altitude")) {
        auto yes = props->Get("vehicle.ardupilot.report_relative_altitude");
        if (yes == "no") {
            report_relative_altitude = false;
            LOG_INFO("VSM will not report relative altitude.");
        } else if (yes == "yes") {
            report_relative_altitude = true;
            LOG_INFO("VSM will report relative altitude.");
        } else {
            LOG_ERR("Invalid value '%s' for report_relative_altitude", yes.c_str());
        }
    }
}

void
Ardupilot_vehicle::Update_capability_states()
{
    Capability_states states;
    auto status = Get_system_status();

    switch (Get_type()) {
    case Type::COPTER:
    case Type::PLANE:
        if (status.control_mode != Sys_status::Control_mode::MANUAL) {
            states.Set(Capability_state::MANUAL_MODE_ENABLED);
        }
        if (status.state == Sys_status::State::ARMED) {
            if (status.control_mode == Sys_status::Control_mode::AUTO) {
                states.Set(Capability_state::PAUSE_MISSION_ENABLED);
            } else {
                states.Set(Capability_state::AUTO_MODE_ENABLED);
                states.Set(Capability_state::RESUME_MISSION_ENABLED);
            }
            if (status.control_mode == Sys_status::Control_mode::GUIDED) {
                states.Set(Capability_state::PAUSE_MISSION_ENABLED);
            } else {
                states.Set(Capability_state::GUIDED_MODE_ENABLED);
            }
            if (status.control_mode == Sys_status::Control_mode::JOYSTICK) {
                states.Set(Capability_state::DIRECT_VEHICLE_CONTROL_ENABLED);
            } else {
                states.Set(Capability_state::JOYSTICK_MODE_ENABLED);
            }

            if (Get_type() == Type::COPTER) {
                // Land only for copter.
                states.Set(Capability_state::LAND_ENABLED);
            }
            states.Set(Capability_state::DISARM_ENABLED);
            states.Set(Capability_state::WAYPOINT_ENABLED);
            states.Set(Capability_state::RETURN_HOME_ENABLED);
        } else {
            states.Set(Capability_state::ARM_ENABLED);
        }
        break;
    case Type::ROVER:
        states.Set(Capability_state::RETURN_HOME_ENABLED);
        if (status.control_mode != Sys_status::Control_mode::AUTO) {
            states.Set(Capability_state::AUTO_MODE_ENABLED);
        }
        if (status.control_mode != Sys_status::Control_mode::MANUAL) {
            states.Set(Capability_state::MANUAL_MODE_ENABLED);
        }
        break;
    case Type::OTHER:;
    }
    Set_capability_states(states);
}
