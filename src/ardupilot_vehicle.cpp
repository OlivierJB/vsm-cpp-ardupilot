// Copyright (c) 2014, Smart Projects Holdings Ltd
// All rights reserved.
// See LICENSE file for license details.

#include <ardupilot_vehicle.h>

const ugcs::vsm::Mavlink_demuxer::System_id Mavlink_vehicle::VSM_SYSTEM_ID = 1;

/* Reference Mavlink implementation (ArduPilot) source code
 * (as for 17-July-2013) has the following comment:
 *
 * "Currently we are not checking for correct compid since APM is not
 *  passing mavlink info to any subsystem.
 *  If it is addressed to our system ID we assume it is for us"
 *
 *  In other words, component ID is ignored when packet is received by
 *  APM. To make the situation even worse, all packets generated by APM
 *  has component ID of 1, which is a hard-coded value. Thats why here
 *  same default component ID is used for all operations.
 */
const ugcs::vsm::Mavlink_demuxer::Component_id Mavlink_vehicle::VSM_COMPONENT_ID = 1;

using namespace ugcs::vsm;

void
Ardupilot_vehicle::On_enable()
{
    // Get parameter values.
    Mavlink_vehicle::On_enable();
    read_version.version_handler = Read_version::Make_version_handler(
        &Ardupilot_vehicle::On_autopilot_version,
        Shared_from_this());

    // We need to understand only that FS_EKF_ACTION is supported.
    read_version.Enable();

    read_waypoints.item_handler = Read_waypoints::Make_mission_item_handler(
        &Ardupilot_vehicle::On_mission_item,
        Shared_from_this());

    // Poll for home location until it becomes valid.
    home_location_timer =
        Timer_processor::Get_instance()->Create_timer(
            std::chrono::seconds(3),
            Make_callback(
                &Ardupilot_vehicle::On_home_location_timer,
                Shared_from_this()),
            Get_completion_ctx());

    Get_home_location();
}

void
Ardupilot_vehicle::On_disable()
{
    home_location_timer->Cancel();
    Mavlink_vehicle::On_disable();
}

void
Ardupilot_vehicle::On_autopilot_version(ugcs::vsm::mavlink::Pld_autopilot_version ver)
{
    int maj = (ver->flight_sw_version.Get() >> 24) & 0xff;
    int min = (ver->flight_sw_version.Get() >> 16) & 0xff;
    int patch = (ver->flight_sw_version.Get() >> 8) & 0xff;
    int type = (ver->flight_sw_version.Get() >> 0) & 0xff;
    LOG("Ardupilot version=%d.%d.%d, type=%d", maj, min, patch, type);

    if (ver->flight_sw_version.Get() >= ARDUPILOT_VERSION(3, 3, 1)) {
        use_ekf_action_as_gps_failsafe = true;
        send_home_position_as_mav_cmd = true;
    }
}

void
Ardupilot_vehicle::On_mission_item(ugcs::vsm::mavlink::Pld_mission_item mi)
{
    if (mi->seq == 0) {
        home_location.latitude = mi->x * M_PI / 180;
        home_location.longitude = mi->y * M_PI / 180;

        if (Is_home_position_valid()) {
            VEHICLE_LOG_INF(*this, "Got home position: x=%f, y=%f", mi->x.Get(), mi->y.Get());
            auto report = Open_telemetry_report();
            report->Set<tm::Home_position>(home_location);
        }
    }
}

bool
Ardupilot_vehicle::Is_home_position_valid()
{
    return (home_location.latitude != 0) || (home_location.longitude != 0);
}

bool
Ardupilot_vehicle::On_home_location_timer()
{
    // Keep requesting HL until successful.
    if (!Is_home_position_valid()) {
        Get_home_location();
    }
    if (Get_completion_ctx()->Is_enabled()) {
        return true;
    }
    return false;
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_task_request::Handle request)
{
    VEHICLE_LOG_INF((*this), "Starting to handle %zu tasks...", request->actions.size());
    ASSERT(!task_upload.request);
    task_upload.Disable();
    clear_all_missions.Disable();
    /* Mission upload will be done after all existing missions are cleared. */
    clear_all_missions.Set_next_action(
            Activity::Make_next_action(
                    &Task_upload::Enable,
                    &task_upload,
                    request));
    clear_all_missions.Enable(ugcs::vsm::Clear_all_missions());
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_clear_all_missions_request::Handle request)
{
    ASSERT(!task_upload.request);
    clear_all_missions.Disable();
    /* Only clear. */
    clear_all_missions.Enable(*request);
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_command_request::Handle request)
{
    ASSERT(!vehicle_command.vehicle_command_request);
    vehicle_command.Disable();
    vehicle_command.Enable(request);
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type() const
{
    return Get_type(Get_mav_type());
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type(ugcs::vsm::mavlink::MAV_TYPE type)
{
    switch (type) {
    case mavlink::MAV_TYPE::MAV_TYPE_QUADROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_HEXAROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_OCTOROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_TRICOPTER:
    case mavlink::MAV_TYPE::MAV_TYPE_HELICOPTER:
    case mavlink::MAV_TYPE::MAV_TYPE_COAXIAL:
        return Type::COPTER;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_FIXED_WING:
        return Type::PLANE;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_GROUND_ROVER:
        return Type::ROVER;
        break;
    default:
        switch (static_cast<mavlink::ugcs::MAV_TYPE>(type)) {
            case mavlink::ugcs::MAV_TYPE::MAV_TYPE_IRIS:
                return Type::COPTER;
            default:
                break;
        }
        return Type::OTHER;
    }
}

bool
Ardupilot_vehicle::Vehicle_command_act::Try()
{
    if (!remaining_attempts--) {
        VEHICLE_LOG_WRN(vehicle, "Vehicle_command all attempts failed.");
        Disable();
        return false;
    }

    current_timeout = RETRY_TIMEOUT_SHORT;

    /* Create always, it will be assigned to cmd_message, if used. */
    auto cmd_long = mavlink::Pld_command_long::Create();
    mavlink::Pld_mission_item::Ptr cmd_mission_item;
    mavlink::Pld_set_mode::Ptr cmd_set_mode;
    mavlink::Pld_param_set::Ptr param;
    Fill_target_ids(*cmd_long);
    double heading;
    cmd_messages.clear();

    switch (vehicle_command_request->Get_type()) {

    case Vehicle_command::Type::RESUME_MISSION:
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "MIS_RESTART";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        (*param)->param_value = 0;
        cmd_messages.emplace_back(param);
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
        cmd_messages.emplace_back(cmd_long);
        break;

    case Vehicle_command::Type::AUTO_MODE:
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "MIS_RESTART";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        (*param)->param_value = 1;
        cmd_messages.emplace_back(param);
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
        cmd_messages.emplace_back(cmd_long);
        // Reset MIS_RESTART back to 0 so that next time user enters AUTO from
        // RC tx, vehicle continues mission instead of returning back to WP1.
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "MIS_RESTART";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        (*param)->param_value = 0;
        cmd_messages.emplace_back(param);
        break;

    case Vehicle_command::Type::MANUAL_MODE:
        /* Current Ardupilot firmware does not send responses to mode changes,
         * so just check the current mode as an indication of completed
         * request. */
        if (vehicle.Get_system_status().control_mode == Sys_status::Control_mode::MANUAL) {
            vehicle_command_request = Vehicle_request::Result::OK;
        } else {
            cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
            Fill_target_system_id(*cmd_set_mode);
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
            cmd_messages.emplace_back(cmd_set_mode);
        }
        break;

    case Vehicle_command::Type::ARM:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
        (*cmd_long)->param1 = 1; /* Do arm. */
        cmd_messages.emplace_back(cmd_long);
        Register_status_text();
        break;

    case Vehicle_command::Type::DISARM:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
        (*cmd_long)->param1 = 0; /* Do disarm. */
        cmd_messages.emplace_back(cmd_long);
        break;

    case Vehicle_command::Type::PAUSE_MISSION:
        // If vehicle is in guided mode already then
        // briefly move into manual to reset current guided WP and then
        // switch back to guided so the vehicle hovers at current position.
        if (ardu_vehicle.current_copter_flight_mode == Copter_flight_mode::GUIDED) {
            cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
            Fill_target_system_id(*cmd_set_mode);
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
            cmd_messages.emplace_back(cmd_set_mode);
        }
        // Enter GUIDED mode.
        cmd_set_mode = mavlink::Pld_set_mode::Create();
        (*cmd_set_mode)->target_system = vehicle.real_system_id;
        (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
        (*cmd_set_mode)->custom_mode = static_cast<uint32_t>(Copter_flight_mode::GUIDED);
        cmd_messages.emplace_back(cmd_set_mode);
        break;

    case Vehicle_command::Type::GUIDED_MODE:
        // Enter GUIDED mode.
        cmd_set_mode = mavlink::Pld_set_mode::Create();
        (*cmd_set_mode)->target_system = vehicle.real_system_id;
        (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
        (*cmd_set_mode)->custom_mode = static_cast<uint32_t>(Copter_flight_mode::GUIDED);
        cmd_messages.emplace_back(cmd_set_mode);
        break;

    case Vehicle_command::Type::WAYPOINT:
        // Does 4 things:
        // Enter guided mode if needed
        // Change current speed
        // Change yaw if needed
        // Got to WP
        if (ardu_vehicle.current_copter_flight_mode != Copter_flight_mode::GUIDED) {
            // Enter GUIDED mode.
            cmd_set_mode = mavlink::Pld_set_mode::Create();
            (*cmd_set_mode)->target_system = vehicle.real_system_id;
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = static_cast<uint32_t>(Copter_flight_mode::GUIDED);
            cmd_messages.emplace_back(cmd_set_mode);
        }
        param = mavlink::Pld_param_set::Create();
        Fill_target_ids(*param);
        (*param)->param_id = "WPNAV_SPEED";
        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
        (*param)->param_value = vehicle_command_request->Get_speed() * 100;
        cmd_messages.emplace_back(param);
        heading = vehicle_command_request->Get_heading();
        if (!std::isnan(heading)) {
            // we have heading specified. turn first.
            cmd_mission_item = mavlink::Pld_mission_item::Create();
            Fill_target_ids(*cmd_mission_item);
            (*cmd_mission_item)->current = 2;
            (*cmd_mission_item)->frame = mavlink::MAV_FRAME_GLOBAL_RELATIVE_ALT;
            (*cmd_mission_item)->autocontinue = 1;
            (*cmd_mission_item)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
            // yaw angle
            (*cmd_mission_item)->param1 = heading * 180.0 / M_PI;
            // Use default angular speed (AUTO_YAW_SLEW_RATE == 60 deg/s)
            (*cmd_mission_item)->param2 = 0;
            // absolute angle
            (*cmd_mission_item)->param4 = 0;
            cmd_messages.emplace_back(cmd_mission_item);
        }
        cmd_mission_item = mavlink::Pld_mission_item::Create();
        Fill_target_ids(*cmd_mission_item);
        (*cmd_mission_item)->current = 2;
        (*cmd_mission_item)->frame = mavlink::MAV_FRAME_GLOBAL_RELATIVE_ALT;
        (*cmd_mission_item)->autocontinue = 1;
        (*cmd_mission_item)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
        (*cmd_mission_item)->param1 = 0; // hold time
        (*cmd_mission_item)->param2 = vehicle_command_request->Get_acceptance_radius(); // acct radius
        (*cmd_mission_item)->param3 = 0; // passby radius
        (*cmd_mission_item)->param4 = heading * 180.0 / M_PI; // yaw angle
        (*cmd_mission_item)->x = vehicle_command_request->Get_latitude() * 180.0 / M_PI;
        (*cmd_mission_item)->y = vehicle_command_request->Get_longitude() * 180.0 / M_PI;
        (*cmd_mission_item)->z = vehicle_command_request->Get_altitude() - vehicle_command_request->Get_takeoff_altitude();
        cmd_messages.emplace_back(cmd_mission_item);
        break;

    case Vehicle_command::Type::LAND:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
        cmd_messages.emplace_back(cmd_long);
        break;

    case Vehicle_command::Type::RETURN_HOME:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH;
        cmd_messages.emplace_back(cmd_long);
        break;

    default:
        break;
    }

    if (cmd_messages.size()) {
        Send_message(*(cmd_messages.front()));
        Schedule_timer();
        VEHICLE_LOG_DBG(vehicle, "Sending to vehicle: %s", (*(cmd_messages.front())).Dump().c_str());
    } else {
        // Command list is empty, nothing to do.
        Disable();
    }

    return false;
}

void
Ardupilot_vehicle::Vehicle_command_act::Send_next_command(bool previous_command_succeeded)
{
    cmd_messages.pop_front();
    if (previous_command_succeeded) {
        if (cmd_messages.size()) {
            // send next command in chain.
            remaining_attempts = ATTEMPTS;
            Send_message(*(cmd_messages.front()));
            Schedule_timer();
            VEHICLE_LOG_DBG(vehicle, "Sending to vehicle: %s", (*(cmd_messages.front())).Dump().c_str());
        } else {
            // command chain succeeded.
            if (vehicle_command_request) {
                vehicle_command_request = Vehicle_request::Result::OK;
            }
            Disable();
        }
    } else {
        // command failed. return failure to ucs.
        cmd_messages.clear();
        Disable();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_command_ack(
        mavlink::Message<mavlink::MESSAGE_ID::COMMAND_ACK>::Ptr message)
{
    VEHICLE_LOG_DBG(vehicle, "COMAMND_ACK for command %d, res=%d",
            message->payload->command.Get(), message->payload->result.Get());

    if (cmd_messages.size()) {
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        int command_id = cmd->Get_id();
        if (command_id == mavlink::MESSAGE_ID::COMMAND_LONG) {
            command_id = (*std::static_pointer_cast<mavlink::Pld_command_long>(cmd))->command.Get();
        }
        if (message->payload->command.Get() == command_id) {
            // This is a response to our command.
            Send_next_command(message->payload->result == mavlink::MAV_RESULT::MAV_RESULT_ACCEPTED);
        } else {
            VEHICLE_LOG_ERR(vehicle, "Unexpected command acked. Expected: %d", command_id);
        }
    } else {
        // We are not waiting for messages.
        VEHICLE_LOG_ERR(vehicle, "Unexpected COMAMND_ACK");
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_mission_ack(
        mavlink::Message<mavlink::MESSAGE_ID::MISSION_ACK>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "MISSION_ACK, result %d",
            message->payload->type.Get());

    if (cmd_messages.size()) {
        Send_next_command(message->payload->type == mavlink::MAV_MISSION_RESULT::MAV_MISSION_ACCEPTED);
    } else {
        // We are not waiting for messages.
        VEHICLE_LOG_ERR(vehicle, "Unexpected MISSION_ACK");
        Disable();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_param_value(
        mavlink::Message<mavlink::MESSAGE_ID::PARAM_VALUE>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "PARAM_VALUE, %s", message->payload.Dump().c_str());

    if (cmd_messages.size()) {
        std::string param_name;
        mavlink::Float param_value;
        bool is_success = false;
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        switch (cmd->Get_id()) {
        case mavlink::MESSAGE_ID::PARAM_REQUEST_READ:
            param_name = (*std::static_pointer_cast<mavlink::Pld_param_request_read>(cmd))->param_id.Get_string();
            is_success = message->payload->param_id.Get_string() == param_name;
            break;
        case mavlink::MESSAGE_ID::PARAM_SET:
            param_name = (*std::static_pointer_cast<mavlink::Pld_param_set>(cmd))->param_id.Get_string();
            param_value = (*std::static_pointer_cast<mavlink::Pld_param_set>(cmd))->param_value.Get();
            is_success =
                message->payload->param_id.Get_string() == param_name
                &&  message->payload->param_value.Get() == param_value;
            break;
        }
        Send_next_command(is_success);
    } else {
        // We are not waiting for messages.
        VEHICLE_LOG_ERR(vehicle, "Unexpected PARAM_VALUE");
        Disable();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_status_text(
        ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::STATUSTEXT>::Ptr)
{
    /* Assumed command execution started, so wait longer. */
    if (current_timeout != RETRY_TIMEOUT_LONG) {
        current_timeout = RETRY_TIMEOUT_LONG;
        VEHICLE_LOG_DBG(vehicle, "Command execution detected, "
                "now waiting longer for a command to finish...");
        /* Start a new longer timer. */
        Schedule_timer();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::Enable(
        Vehicle_command_request::Handle vehicle_command_request)
{
    this->vehicle_command_request = vehicle_command_request;
    if (ardu_vehicle.Get_type() == Type::OTHER) {
        /* Commands for unknown vehicles types are not supported. */
        Disable();
        return;
    }

    remaining_attempts = ATTEMPTS;

    Register_mavlink_handler<mavlink::MESSAGE_ID::COMMAND_ACK>(
            &Vehicle_command_act::On_command_ack,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::MESSAGE_ID::MISSION_ACK>(
            &Vehicle_command_act::On_mission_ack,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::MESSAGE_ID::PARAM_VALUE>(
            &Vehicle_command_act::On_param_value,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);

    Try();
}

void
Ardupilot_vehicle::Vehicle_command_act::On_disable()
{
    Unregister_mavlink_handlers();
    Unregister_status_text();

    if (timer) {
        timer->Cancel();
        timer = nullptr;
    }

    if (vehicle_command_request) {
        vehicle_command_request = Vehicle_request::Result::NOK;
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::Schedule_timer()
{
    if (timer) {
        timer->Cancel();
    }
    timer = Timer_processor::Get_instance()->Create_timer(
                std::chrono::seconds(current_timeout),
                Make_callback(&Vehicle_command_act::Try, this),
                vehicle.Get_completion_ctx());
}

void
Ardupilot_vehicle::Vehicle_command_act::Register_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Make_statustext_handler(
                    &Ardupilot_vehicle::Vehicle_command_act::On_status_text,
                    this);
}

void
Ardupilot_vehicle::Vehicle_command_act::Unregister_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Statustext_handler();
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_auto_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::AUTO);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::AUTO);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::AUTO);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom auto mode.", ardu_vehicle.Get_type());
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_manual_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::LOITER);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::MANUAL);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::MANUAL);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom manual mode.", ardu_vehicle.Get_type());
}


void
Ardupilot_vehicle::Task_upload::Enable(
        bool success,
        Vehicle_task_request::Handle request)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Previous activity failed, failing also task upload.");
        request = Vehicle_request::Result::NOK;
        Disable();
        return;
    }
    this->request = request;

    Filter_actions();
    Prepare_task_attributes();

    vehicle.write_parameters.Disable();
    vehicle.write_parameters.Set_next_action(
            Write_parameters::Make_next_action(
                    &Task_upload::Task_atributes_uploaded,
                    this));
    vehicle.write_parameters.Enable(task_attributes);
}


void
Ardupilot_vehicle::Task_upload::Task_atributes_uploaded(bool success)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Task attributes upload failed, failing task upload, too.");
        Disable();
        return;
    }

    if (ardu_vehicle.send_home_position_as_mav_cmd) {
        vehicle.do_commands.Disable();
        vehicle.do_commands.Set_next_action(
                Activity::Make_next_action(
                        &Task_upload::Task_commands_sent,
                        this));

        mavlink::Pld_command_long cmd;
        auto hl = request->Get_home_position().Get_geodetic();
        cmd->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
        cmd->param1 = 0; // use specified.
        cmd->param5 = hl.latitude * 180 / M_PI;
        cmd->param6 = hl.longitude * 180 / M_PI;
        cmd->param7 = hl.altitude;

        vehicle.do_commands.Enable({cmd});
    } else {
        Task_commands_sent(true);
    }
}

void
Ardupilot_vehicle::Task_upload::Task_commands_sent(bool success)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Task commands failed, failing task upload, too.");
        Disable();
        return;
    }

    // New home location should be set by now.
    // invalidate current home location and timer handler will retrieve it again.
    ardu_vehicle.home_location.longitude = 0;
    ardu_vehicle.home_location.latitude = 0;

    Prepare_task();
    vehicle.mission_upload.Disable();
    vehicle.mission_upload.mission_items = std::move(prepared_actions);
    vehicle.mission_upload.Set_next_action(
            Activity::Make_next_action(
                    &Task_upload::Mission_uploaded,
                    this));
    vehicle.mission_upload.Enable();

}

void
Ardupilot_vehicle::Task_upload::Mission_uploaded(bool success)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Mission upload to vehicle failed, failing vehicle request.");
        request = Vehicle_request::Result::NOK;
        Disable();
        return;
    }
    /* Everything is OK. */
    request = Vehicle_request::Result::OK;
    Disable();
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_coords(
        mavlink::Pld_mission_item& msg,
        const Geodetic_tuple& tuple, double heading)
{
    msg->x = (tuple.latitude * 180.0) / M_PI;
    msg->y = (tuple.longitude * 180.0) / M_PI;
    /* Fixup absolute altitude - make them relative to
     * take-off altitude.
     */
    msg->z = tuple.altitude - request->Get_takeoff_altitude();
    msg->param4 = (heading * 180.0) / M_PI;
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_common(
        mavlink::Pld_mission_item& msg)
{
    ASSERT(vehicle.real_system_id != Mavlink_demuxer::SYSTEM_ID_ANY);

    Fill_target_ids(msg);
    msg->seq = prepared_actions.size();
    /* APM firmware treats all altitudes as relative. Always. */
    msg->frame = mavlink::MAV_FRAME::MAV_FRAME_GLOBAL_RELATIVE_ALT;
    msg->current = 0;
    msg->autocontinue = 1;
}

void
Ardupilot_vehicle::Task_upload::On_disable()
{
    if (request) {
        request = Vehicle_request::Result::NOK;
    }
    vehicle.write_parameters.Disable();
    vehicle.mission_upload.Disable();
    prepared_actions.clear();
    task_attributes.clear();
    current_mission_poi.Disengage();
    current_mission_heading.Disengage();
    last_move_action = nullptr;
    first_mission_poi_set = false;
    restart_mission_poi = false;
    current_heading = 0;
    heading_to_this_wp = 0;
}

void
Ardupilot_vehicle::Task_upload::Filter_actions()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Filter_copter_actions();
        return;
    case Type::PLANE:
        Filter_plane_actions();
        return;
    case Type::ROVER:
        Filter_rover_actions();
        return;
    case Type::OTHER:
        Filter_other_actions();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d.",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Filter_copter_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_plane_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_rover_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_other_actions()
{
    /* Only move is supported. Safe. */
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::MOVE:
            iter++;
            continue;
        default:
            VEHICLE_LOG_WRN(vehicle, "Action type %d ignored.", (*iter)->Get_type());
            break;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task()
{
    prepared_actions.clear();

    /* Ardupilot waypoint at index zero is always treated as home position,
     * so ensure it is always present. In other words, real waypoint should not
     * be stored at zero index.
     */
    Set_home_action::Ptr set_home_action = Set_home_action::Create(
            false /* use specified. */,
            request->Get_home_position(),
            0 /* elevation. */);

    Prepare_action(set_home_action);

    bool first_set_home_found = false;

    last_move_action = nullptr;
    for (auto& iter:request->actions) {
        switch (iter->Get_type()) {
        case Action::Type::SET_HOME:
            if (!first_set_home_found) {
                /* Skip first set_home, it has been already processed and put
                 * into waypoint index zero. */
                first_set_home_found = true;
            } else {
                /* To be tested. */
                Prepare_action(iter);
            }
            break;
        default:
            Prepare_action(iter);
            break;
        }
    }

    if (last_move_action) {
        Prepare_action(last_move_action);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task_attributes()
{
    task_attributes.clear();
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Prepare_copter_task_attributes();
        return;
    case Type::PLANE:
        Prepare_plane_task_attributes();
        return;
    case Type::ROVER:
        Prepare_rover_task_attributes();
        return;
    case Type::OTHER:
        Prepare_other_task_attributes();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Prepare_copter_task_attributes()
{
    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    using Emerg = Task_attributes_action::Emergency_action;

    /* Battery failsafe. */
    param->param_id = "FS_BATT_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->low_battery) {
    case Emerg::GO_HOME:
        param->param_value = 2;
        break;
    case Emerg::LAND:
        param->param_value = 1;
        break;
    case Emerg::WAIT:
        /* There is no support for such behavior. Override with land. */
        param->param_value = 1;
        break;
    case Emerg::CONTINUE:
        param->param_value = 0;
        break;
    }
    task_attributes.push_back(param);

    /* GNSS loss failsafe. */
    if (ardu_vehicle.use_ekf_action_as_gps_failsafe) {
        param->param_id = "FS_EKF_ACTION";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        switch (request->attributes->gnss_loss) {
        case Emerg::LAND:
            param->param_value = 1;
            break;
        case Emerg::WAIT:
            param->param_value = 2;
            break;
        default:
            LOG_WARN("Invalid FS action for GPS");
            break;
        }
    } else {
        param->param_id = "FS_GPS_ENABLE";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        switch (request->attributes->gnss_loss) {
        case Emerg::LAND:
            param->param_value = 3;
            break;
        case Emerg::WAIT:
            param->param_value = 2;
            break;
        default:
            LOG_WARN("Invalid FS action for GPS");
            break;
        }
    }
    task_attributes.push_back(param);

    /* Radio Control loss failsafe. */
    param->param_id = "FS_THR_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->rc_loss) {
    case Emerg::GO_HOME:
        param->param_value = 1;
        break;
    case Emerg::LAND:
        param->param_value = 3;
        break;
    case Emerg::WAIT:
        /* Wait not supported, do land. */
        param->param_value = 3;
        break;
    case Emerg::CONTINUE:
        /* Continue in auto, land in other modes. */
        param->param_value = 2;
        break;
    }
    task_attributes.push_back(param);


    int16_t safe_alt = (request->attributes->safe_altitude - request->Get_takeoff_altitude()) * 100;
    if (safe_alt == 0) {
        safe_alt = 1;   // Avoid landing.
    }
    /* RTL altitude. */
    param->param_id = "RTL_ALT";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
    param->param_value = safe_alt;
    task_attributes.push_back(param);

    /* RTL Final altitude. Set to the same as RTL_ALT.
     * This makes it hover after RTL. 0 would mean land.*/
    param->param_id = "RTL_ALT_FINAL";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
    param->param_value = safe_alt;
    task_attributes.push_back(param);

    /* Don't change yaw during auto mission, because there is an auto-POI
     * feature. Besides that, duplicated waypoints are used to implement
     * actions like panorama, so it is not desirable to change the yaw while
     * switching between waypoints sharing the same location. */
    param->param_id = "WP_YAW_BEHAVIOR";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Never change yaw. */
    task_attributes.push_back(param);

#if 0 /* Wait until supported. */
    /* Mount control mode. */
    param->param_id = "MNT_MODE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 2; /* Mavlink targeting. */
    task_attributes.push_back(param);
#endif

    param->param_id = "CAM_TRIGG_TYPE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Servo trigger type. */
    task_attributes.push_back(param);
}

void
Ardupilot_vehicle::Task_upload::Prepare_plane_task_attributes()
{
    /* Add plane specific task attributes */
    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    for (auto & p : request->parameters) {
        auto a = p->Get_action<Action::Type::SET_PARAMETER>();
        switch (a->param_type) {
        case mavlink::ugcs::LANDING_FLARE_ALTITUDE:
            param->param_id = "LAND_FLARE_ALT";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            param->param_value = a->param_value;
            break;
        case mavlink::ugcs::LANDING_FLARE_TIME:
            param->param_id = "LAND_FLARE_SEC";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            param->param_value = a->param_value;
            break;
        case mavlink::ugcs::MIN_LANDING_PITCH:
            param->param_id = "LAND_PITCH_CD";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
            param->param_value = static_cast<int16_t>(a->param_value * 18000 / M_PI);
            break;
        case mavlink::ugcs::LANDING_FLARE_DAMP:
            param->param_id = "TECS_LAND_DAMP";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            param->param_value = a->param_value;
            break;
        case mavlink::ugcs::LANDING_APPROACH_AIRSPEED:
            param->param_id = "TECS_LAND_ARSPD";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            param->param_value = a->param_value;
            break;
        case mavlink::ugcs::LANDING_SPEED_WEIGHTING:
            param->param_id = "TECS_LAND_SPDWGT";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            param->param_value = a->param_value;
            break;
        case mavlink::ugcs::MAX_AUTO_FLIGHT_PITCH:
            param->param_id = "TECS_PITCH_MAX";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            param->param_value = static_cast<int8_t>(a->param_value * 180 / M_PI);
            break;
        case mavlink::ugcs::MAX_PITCH:
            param->param_id = "LIM_PITCH_MAX";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
            param->param_value = static_cast<int16_t>(a->param_value * 180 / M_PI);
            break;
        case mavlink::ugcs::MIN_THROTTLE:
            param->param_id = "THR_MIN";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            param->param_value = static_cast<int8_t>(a->param_value);
            break;
        case mavlink::ugcs::LANDING_SINK_RATE:
            param->param_id = "TECS_LAND_SINK";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
            param->param_value = a->param_value;
            break;
        case mavlink::ugcs::LANDING_RANGEFINDER_ENABLED:
            param->param_id = "RNGFND_LANDING";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            param->param_value = static_cast<int8_t>(a->param_value);
            break;
        case mavlink::ugcs::MIN_RANGEFINDER_DISTANCE:
            param->param_id = "RNGFND_MIN_CM";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
            param->param_value = static_cast<int16_t>(a->param_value);
            break;
        }
        task_attributes.push_back(param);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_rover_task_attributes()
{
    /* Add rover specific task attributes */
}

void
Ardupilot_vehicle::Task_upload::Prepare_other_task_attributes()
{
    /* Stub. */
}

void
Ardupilot_vehicle::Task_upload::Prepare_action(Action::Ptr action)
{
    switch (action->Get_type()) {
    case Action::Type::MOVE:
        Prepare_move(action);
        return;
    case Action::Type::WAIT:
        Prepare_wait(action);
        return;
    case Action::Type::PAYLOAD_STEERING:
        Prepare_payload_steering(action);
        return;
    case Action::Type::TAKEOFF:
        Prepare_takeoff(action);
        return;
    case Action::Type::LANDING:
        Prepare_landing(action);
        return;
    case Action::Type::CHANGE_SPEED:
        Prepare_change_speed(action);
        return;
    case Action::Type::SET_HOME:
        Prepare_set_home(action);
        return;
    case Action::Type::POI:
        Prepare_POI(action);
        return;
    case Action::Type::HEADING:
        Prepare_heading(action);
        return;
    case Action::Type::PANORAMA:
        Prepare_panorama(action);
        return;
    case Action::Type::CAMERA_CONTROL:
        VSM_EXCEPTION(Internal_error_exception, "CAMERA_CONTROL action not supported.");
    case Action::Type::CAMERA_TRIGGER:
        Prepare_camera_trigger(action);
        return;
    case Action::Type::TASK_ATTRIBUTES:
        VSM_EXCEPTION(Internal_error_exception, "TASK_ATTRIBUTES action not supported.");
    case Action::Type::CAMERA_SERIES_BY_TIME:
        Prepare_camera_series_by_time(action);
        return;
    case Action::Type::CAMERA_SERIES_BY_DISTANCE:
        Prepare_camera_series_by_distance(action);
        return;
    case Action::Type::SET_PARAMETER:
        VSM_EXCEPTION(Internal_error_exception, "SET_PARAMETER action not supported.");
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unsupported action [%s]",
            action->Get_name().c_str());
}

void
Ardupilot_vehicle::Task_upload::Add_mission_item(mavlink::Pld_mission_item::Ptr mi)
{
    Fill_mavlink_mission_item_common(*mi);
    prepared_actions.push_back(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_move(Action::Ptr& action)
{
    /* Turn off camera series if active. */
    if (!camera_series_by_dist_active_in_wp) {
        if (camera_series_by_dist_active) {

            camera_series_by_dist_active = false;
            Camera_series_by_distance_action::Ptr a =
                action->Get_action<Action::Type::CAMERA_SERIES_BY_DISTANCE>();
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
            Add_mission_item(mi);
        }
    }
    if (!camera_series_by_time_active_in_wp) {
        if (camera_series_by_time_active) {
            camera_series_by_time_active = false;

            Camera_series_by_time_action::Ptr a =
                action->Get_action<Action::Type::CAMERA_SERIES_BY_TIME>();
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
            (*mi)->param1 = ardu_vehicle.camera_servo_idx;
            Add_mission_item(mi);
        }
    }
    camera_series_by_dist_active_in_wp = false;
    camera_series_by_time_active_in_wp = false;

    if (last_move_action) {
        auto from = last_move_action->Get_action<Action::Type::MOVE>();
        auto to = action->Get_action<Action::Type::MOVE>();
        float calculated_heading = from->position.Bearing(to->position);
        // Handle several waypoints at the same coords.
        if (!std::isnan(calculated_heading)) {
            calculated_heading = Normalize_angle_0_2pi(calculated_heading);
            heading_to_this_wp = calculated_heading;
        } else {
            // Use previously calculated heading_to_this_wp.
        }
    }

    if (current_mission_poi) {
        if (!first_mission_poi_set && (ardu_vehicle.auto_generate_mission_poi || restart_mission_poi)) {
            // Add automatic POI on each consecutive WP.
            LOG("Set AutoPOI");
            Add_mission_item(Build_roi_mission_item(*current_mission_poi));
        }
    } else {
        if (current_mission_heading) {
            // Set current heading as yaw angle.
            current_heading = *current_mission_heading;
        } else {
            // Set heading to next waypoint as yaw angle.
            current_heading = heading_to_this_wp;
        }
        if (last_move_action) {
            LOG("Set Autoheading to %f", current_heading);
            Add_mission_item(Build_heading_mission_item(current_heading));
        }
    }

    Add_mission_item(Build_wp_mission_item(action));
    last_move_action = action;

    restart_mission_poi = false;
    first_mission_poi_set = false;
    current_mission_heading.Disengage();
}

void
Ardupilot_vehicle::Task_upload::Prepare_wait(Action::Ptr& action)
{
    /* Create additional waypoint on the current position to wait. */
    if (last_move_action) {
        if (!current_mission_poi) {
            Add_mission_item(Build_heading_mission_item(
                    Normalize_angle_0_2pi(current_heading)));
        }
        first_mission_poi_set = false;
        restart_mission_poi = true;
        Wait_action::Ptr wa = action->Get_action<Action::Type::WAIT>();
        auto wp = Build_wp_mission_item(last_move_action);
        (*wp)->param1 = wa->wait_time;
        Add_mission_item(wp);
    } else {
        VEHICLE_LOG_WRN(vehicle, "No move action before wait action, ignored.");
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_payload_steering(Action::Ptr&)
{
    ASSERT(false); /* Not implemented yet */
}

void
Ardupilot_vehicle::Task_upload::Prepare_takeoff(Action::Ptr& action)
{
    /* Ardupilot does not fly to the takeoff position after takeoff
     * is done. Add explicit waypoint after the takeoff command with
     * target coordinates.
     */
    auto takeoff = action->Get_action<Action::Type::TAKEOFF>();
    auto explicit_wp = Move_action::Create(
            takeoff->position,
            0,
            takeoff->acceptance_radius,
            0,
            takeoff->heading,
            takeoff->elevation
    );

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_TAKEOFF;
    (*mi)->param1 = 0; /* No data for pitch. */
    Fill_mavlink_mission_item_coords(*mi, takeoff->position.Get_geodetic(), takeoff->heading);
    Add_mission_item(mi);
    Prepare_action(explicit_wp);
}

void
Ardupilot_vehicle::Task_upload::Prepare_landing(Action::Ptr& action)
{
    /* Ardupilot does not take the altitude of the landing, so
     * add explicit waypoint guiding vehicle to the landing start
     * position.
     */
    auto land = action->Get_action<Action::Type::LANDING>();
    auto explicit_wp = Move_action::Create(
            land->position,
            0,
            land->acceptance_radius,
            0,
            land->heading,
            land->elevation
    );
    Prepare_action(explicit_wp);

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
    Fill_mavlink_mission_item_coords(*mi, land->position.Get_geodetic(), land->heading);
    Add_mission_item(mi);

    /* Don't duplicate waypoint if last action is land. */
    last_move_action = nullptr;
}

void
Ardupilot_vehicle::Task_upload::Prepare_change_speed(Action::Ptr& action)
{
    Change_speed_action::Ptr la = action->Get_action<Action::Type::CHANGE_SPEED>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        /* ArduCopter version up to 3.2 use p1 for speed and ignores p2.
         * ArduCopter version up to 3.2+ use p2 for speed and ignores p1.
         * So, we set both, here.
         * Later, if MAV_CMD_DO_CHANGE_SPEED handling changes changes
         * in ArduPilotwe will need to implement FW version checking.
         */
        (*mi)->param1 = la->speed;
        (*mi)->param2 = la->speed;
        break;
    case Type::ROVER:
    default:
        /* Ground rover takes only airspeed into account, others seems to
         * take both, but we have only airspeed from UCS, so use only air. */
        (*mi)->param1 = 0; /* Airspeed. */
        (*mi)->param2 = la->speed;
        break;
    }

    (*mi)->param3 = -1; /* Throttle no change. */
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_set_home(Action::Ptr& action)
{
    Set_home_action::Ptr sa = action->Get_action<Action::Type::SET_HOME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
    (*mi)->param1 = sa->use_current_position ? 1 : 0;
    Fill_mavlink_mission_item_coords(*mi, sa->home_position.Get_geodetic(), 0);
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_POI(Action::Ptr& action)
{
    Poi_action::Ptr pa = action->Get_action<Action::Type::POI>();
    if (pa->active) {
        // Set up POI for succeeding waypoints.
        current_mission_poi = pa->position.Get_geodetic();
        Add_mission_item(Build_roi_mission_item(*current_mission_poi));
        first_mission_poi_set = true;
    } else {
        // Reset POI. Generate next WPs as heading from now on.
        current_mission_poi.Disengage();
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_heading(Action::Ptr& action)
{
    Heading_action::Ptr ha = action->Get_action<Action::Type::HEADING>();
    Add_mission_item(Build_heading_mission_item(ha->heading));
    current_heading = ha->heading;
    current_mission_heading = ha->heading;
    // Heading action terminates current POI.
    restart_mission_poi = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_series_by_distance(Action::Ptr& action)
{
    Camera_series_by_distance_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_SERIES_BY_DISTANCE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
    (*mi)->param1 = a->interval;
    Add_mission_item(mi);
    camera_series_by_dist_active = true;
    camera_series_by_dist_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_series_by_time(Action::Ptr& action)
{
    Camera_series_by_time_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_SERIES_BY_TIME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    (*mi)->param3 = a->count ? *a->count : 0xffff;
    (*mi)->param4 = static_cast<float>(a->interval.count()) / 1000.0;
    Add_mission_item(mi);
    camera_series_by_time_active = true;
    camera_series_by_time_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_trigger(Action::Ptr& action)
{
    Camera_trigger_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_TRIGGER>();
    if (a->state != Camera_trigger_action::State::SINGLE_PHOTO &&
        a->state != Camera_trigger_action::State::SERIAL_PHOTO) {

        return;
    }
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    if (a->state == Camera_trigger_action::State::SINGLE_PHOTO) {
        (*mi)->param3 = 1;
        (*mi)->param4 = ardu_vehicle.camera_servo_time;
    } else {
        (*mi)->param3 = 0xffff;
        (*mi)->param4 = static_cast<float>(a->interval.count()) / 1000.0;
        camera_series_by_time_active = true;
        camera_series_by_time_active_in_wp = true;
    }
    Add_mission_item(mi);
    camera_series_by_time_active = true;
    camera_series_by_time_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_panorama(Action::Ptr& action)
{
    Panorama_action::Ptr panorama = action->Get_action<Action::Type::PANORAMA>();

    if (!last_move_action) {
        VEHICLE_LOG_WRN(vehicle, "No previous move action found to generate panorama action, ignored.");
        return;
    }
//    LOG("Panorama angle=%f, speed=%f, step=%f, delay=%lu",
//            panorama->angle,
//            panorama->speed,
//            panorama->step,
//            panorama->delay.count()
//            );

    /* Panorama is always done in steps less then 180 degree to make sure that
     * turns over 180 degrees are supported.
     */
    double MAX_STEP = 3;
    double speed = std::abs(panorama->speed);
    if (speed == 0 || speed > 1) {
        speed = 1; /* 1 rad/second assumed max speed. */
    }

    float cur_angle = 0;
    float target_angle = std::abs(panorama->angle);
    float step = MAX_STEP;
    int delay = 0;
    // Set delay to slightly more than the calculated time.
    double panorama_duration = std::abs(panorama->angle) / speed + 3;

    switch (panorama->trigger_state) {
    case Panorama_action::Trigger_state::ON:
        break;
    case Panorama_action::Trigger_state::SERIAL:
        /* Per-sector delay. */
        delay = std::chrono::duration_cast<std::chrono::seconds>(panorama->delay).count();
        // non zero delay. Use step from action.
        step = std::abs(panorama->step);
        // Add some time the delay to make the turn.
        delay += step / speed + 2;
        // do not add the long pause waypoint at the end.
        panorama_duration = 0;
        break;
    }

    if (step == 0) {
        VEHICLE_LOG_WRN(vehicle, "Zero step angle, ignoring panorama.");
        return;
    }

    Add_mission_item(Build_heading_mission_item(current_heading));
    /* Create additional waypoint at the current position with wait to
     * stabilize before doing panorama. */
    auto waiter = Build_wp_mission_item(last_move_action);
    (*waiter)->param1 = 2; /* seconds. */
    Add_mission_item(waiter);

    // Set off the trigger
    Add_camera_trigger_item();

    while (cur_angle < target_angle) {
        if (cur_angle + step > target_angle) {
            step = target_angle - cur_angle;
        }

        float cur_step_angle = 0;
        while (cur_step_angle < step) {
            if (step > MAX_STEP) {
                cur_step_angle += MAX_STEP;
            } else {
                cur_step_angle += step;
            }
            if (cur_step_angle > step) {
                cur_step_angle = step;
            }
            float temp_heading = cur_angle + cur_step_angle;
            if (panorama->angle < 0) {
                temp_heading = -temp_heading;
            }
            Add_mission_item(Build_heading_mission_item(
                    Normalize_angle_0_2pi(current_heading + temp_heading),
                    speed));
        }
        if (delay) {
            waiter = Build_wp_mission_item(last_move_action);
            (*waiter)->param1 = delay;
            Add_mission_item(waiter);

            // Set off trigger
            Add_camera_trigger_item();
        }
        cur_angle += cur_step_angle;
    }
    if (panorama->angle > 0) {
        current_heading = Normalize_angle_0_2pi(current_heading + target_angle);
    } else {
        current_heading = Normalize_angle_0_2pi(current_heading - target_angle);
    }


    /* Create a waypoint with hold time slightly more than estimated
     * panorama duration. Used only with Trigger_state::ON.
     */
    if (panorama_duration) {
        VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is %f seconds.", panorama_duration);
        auto long_wait = Build_wp_mission_item(last_move_action);
        if (panorama_duration > 255) {
            VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is truncated to 255 seconds.");
            (*long_wait)->param1 = 255; /* Max possible wait for Ardupilot. */
        } else {
            (*long_wait)->param1 = panorama_duration;
        }
        Add_mission_item(long_wait);
        LOG("long_wait WP %f", panorama_duration);
    }
    // panorama action terminates current POI.
    restart_mission_poi = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_control(Action::Ptr& action)
{
    Camera_control_action::Ptr cam_control =
            action->Get_action<Action::Type::CAMERA_CONTROL>();

    /* TODO wait until supported by Ardupilot. */
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL;
    Add_mission_item(mi);

}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_heading_mission_item(
        float heading,
        float speed,
        bool absolute_angle,
        bool clockwise
        )
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
    (*mi)->param1 = (Normalize_angle_0_2pi(heading) * 180.0) / M_PI;
    (*mi)->param2 = (speed * 180) / M_PI;
    (*mi)->param3 = clockwise? 1: -1;       // Not implemented in AP.
    (*mi)->param4 = absolute_angle? 0: 1;   /* absolute angle. */
    return mi;
}

void
Ardupilot_vehicle::Task_upload::Add_camera_trigger_item()
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    (*mi)->param3 = 1;
    (*mi)->param4 = ardu_vehicle.camera_servo_time;
    Add_mission_item(mi);
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_roi_mission_item(const Geodetic_tuple& coords)
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_ROI;
    if (coords.latitude == 0 && coords.longitude == 0 && coords.altitude == 0)
    {
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_NONE;
    } else {
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_LOCATION;
    }
    Fill_mavlink_mission_item_coords(*mi, coords, 0);
    return mi;
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_wp_mission_item(Action::Ptr& action)
{
    Move_action::Ptr ma = action->Get_action<Action::Type::MOVE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    switch (ma->turn_type) {
    case Move_action::TURN_TYPE_SPLINE:
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT;
        break;
    default:
        VEHICLE_LOG_WRN(vehicle, "Invalid turn type: %d, defaulting to 'straight'.", ma->turn_type);
    case Move_action::TURN_TYPE_STRAIGHT:
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
        break;
    }
    (*mi)->param1 = ma->wait_time * 10;
    /* Set acceptance radius to something reasonable. */
    if (ma->acceptance_radius < ACCEPTANCE_RADIUS_MIN) {
        (*mi)->param2 = ACCEPTANCE_RADIUS_MIN;
        VEHICLE_LOG_INF(vehicle, "Acceptance radius normalized from %f to %f",
                ma->acceptance_radius, (*mi)->param2.Get());
    } else {
        (*mi)->param2 = ma->acceptance_radius;
    }
    (*mi)->param3 = ma->loiter_orbit;
    Fill_mavlink_mission_item_coords(*mi, ma->position.Get_geodetic(), ma->heading);
    return mi;
}

void
Ardupilot_vehicle::Process_heartbeat(
            ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::HEARTBEAT>::Ptr message)
{
    Sys_status::Control_mode control_mode = Sys_status::Control_mode::UNKNOWN;
    auto new_mode = static_cast<Copter_flight_mode>(message->payload->custom_mode.Get());
    switch (Get_type()) {
    case Type::COPTER:
        if (new_mode != current_copter_flight_mode) {
            LOG("Copter mode changed from %d to %d", current_copter_flight_mode, new_mode);
        }
        current_copter_flight_mode = new_mode;
        control_mode = Map_copter_flight_mode(current_copter_flight_mode);
        break;
    case Type::ROVER:
        control_mode = Map_rover_flight_mode(static_cast<Rover_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::PLANE:
        control_mode = Map_plane_flight_mode(static_cast<Plane_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::OTHER:;
    }

    Sys_status::State state = Sys_status::State::DISARMED;
    if (message->payload->base_mode.Get() & mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED) {
        state = Sys_status::State::ARMED;
    }

    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - recent_connect);

    Set_system_status(Sys_status(true, true, control_mode, state, uptime));
    Update_capability_states();
}

void
Ardupilot_vehicle::Get_home_location()
{
    read_waypoints.Disable();
    read_waypoints.Get_home_location();
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_copter_flight_mode(Copter_flight_mode custom_mode)
{

    switch (custom_mode) {
    case Copter_flight_mode::GUIDED:
        return Sys_status::Control_mode::GUIDED;
    case Copter_flight_mode::AUTO:
    case Copter_flight_mode::RTL:
    case Copter_flight_mode::CIRCLE:
    case Copter_flight_mode::LAND:
    case Copter_flight_mode::AUTOTUNE:
        return Sys_status::Control_mode::AUTO;
    case Copter_flight_mode::STABILIZE:
    case Copter_flight_mode::ACRO:
    case Copter_flight_mode::ALT_HOLD:
    case Copter_flight_mode::OF_LOITER:
    case Copter_flight_mode::LOITER:
    case Copter_flight_mode::DRIFT:
    case Copter_flight_mode::SPORT:
    case Copter_flight_mode::FLIP:
        return Sys_status::Control_mode::MANUAL;
    }
    return Sys_status::Control_mode::UNKNOWN;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_plane_flight_mode(Plane_flight_mode custom_mode)
{
    switch (custom_mode) {
    case Plane_flight_mode::AUTO:
    case Plane_flight_mode::LOITER:
    case Plane_flight_mode::CIRCLE:
    case Plane_flight_mode::RTL:
    case Plane_flight_mode::GUIDED:
        return Sys_status::Control_mode::AUTO;
    case Plane_flight_mode::MANUAL:
    case Plane_flight_mode::STABILIZE:
    case Plane_flight_mode::TRAINING:
    case Plane_flight_mode::ACRO:
    case Plane_flight_mode::FLY_BY_WIRE_A:
    case Plane_flight_mode::FLY_BY_WIRE_B:
    case Plane_flight_mode::CRUISE:
        return Sys_status::Control_mode::MANUAL;
    case Plane_flight_mode::INITIALISING:;
        /* Fall down to unknown. */
    }

    return Sys_status::Control_mode::UNKNOWN;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_rover_flight_mode(Rover_flight_mode custom_mode)
{
    switch (custom_mode) {
    case Rover_flight_mode::AUTO:
    case Rover_flight_mode::RTL:
    case Rover_flight_mode::GUIDED:
        return Sys_status::Control_mode::AUTO;
    case Rover_flight_mode::MANUAL:
    case Rover_flight_mode::LEARNING:
    case Rover_flight_mode::STEERING:
    case Rover_flight_mode::HOLD:
        return Sys_status::Control_mode::MANUAL;
    case Rover_flight_mode::INITIALISING:;
    /* Fall down to unknown. */
    }

    return Sys_status::Control_mode::UNKNOWN;
}

void
Ardupilot_vehicle::Update_capabilities()
{
    switch (Get_type()) {
    case Type::COPTER:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::ARM_AVAILABLE,
                    Vehicle::Capability::DISARM_AVAILABLE,
                    Vehicle::Capability::WAYPOINT_AVAILABLE,
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::GUIDED_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::PAUSE_MISSION_AVAILABLE,
                    Vehicle::Capability::RESUME_MISSION_AVAILABLE,
                    Vehicle::Capability::LAND_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::PLANE:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::ARM_AVAILABLE,
                    Vehicle::Capability::DISARM_AVAILABLE,
                    Vehicle::Capability::WAYPOINT_AVAILABLE,
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::GUIDED_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::PAUSE_MISSION_AVAILABLE,
                    Vehicle::Capability::RESUME_MISSION_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::ROVER:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::OTHER:;
    }
    /* Others don't support anything. */
    Set_capabilities(Capabilities());
}

void
Ardupilot_vehicle::Configure()
{
    auto props = ugcs::vsm::Properties::Get_instance().get();
    camera_servo_idx = props->Get_int("vehicle.ardupilot.camera_servo_idx");
    camera_servo_pwm = props->Get_int("vehicle.ardupilot.camera_servo_pwm");
    camera_servo_time = props->Get_float("vehicle.ardupilot.camera_servo_time");
}

void
Ardupilot_vehicle::Update_capability_states()
{
    Capability_states states;
    auto status = Get_system_status();

    switch (Get_type()) {
    case Type::COPTER:
        if (status.state == Sys_status::State::ARMED) {
            if (status.control_mode != Sys_status::Control_mode::AUTO) {
                states.Set(Capability_state::AUTO_MODE_ENABLED);
            }
            if (status.control_mode != Sys_status::Control_mode::MANUAL) {
                states.Set(Capability_state::MANUAL_MODE_ENABLED);
            }
            if (status.control_mode != Sys_status::Control_mode::GUIDED) {
                states.Set(Capability_state::GUIDED_MODE_ENABLED);
            }
            states.Set(Capability_state::DISARM_ENABLED);
            states.Set(Capability_state::WAYPOINT_ENABLED);
            states.Set(Capability_state::PAUSE_MISSION_ENABLED);
            states.Set(Capability_state::RESUME_MISSION_ENABLED);
            states.Set(Capability_state::RETURN_HOME_ENABLED);
            states.Set(Capability_state::LAND_ENABLED);
        } else {
            states.Set(Capability_state::ARM_ENABLED);
        }
        break;
    case Type::PLANE:
        if (status.state == Sys_status::State::ARMED) {
            if (status.control_mode != Sys_status::Control_mode::AUTO) {
                states.Set(Capability_state::AUTO_MODE_ENABLED);
            }
            if (status.control_mode != Sys_status::Control_mode::MANUAL) {
                states.Set(Capability_state::MANUAL_MODE_ENABLED);
            }
            if (status.control_mode != Sys_status::Control_mode::GUIDED) {
                states.Set(Capability_state::GUIDED_MODE_ENABLED);
            }
            states.Set(Capability_state::DISARM_ENABLED);
            states.Set(Capability_state::WAYPOINT_ENABLED);
            states.Set(Capability_state::PAUSE_MISSION_ENABLED);
            states.Set(Capability_state::RESUME_MISSION_ENABLED);
            states.Set(Capability_state::RETURN_HOME_ENABLED);
        } else {
            states.Set(Capability_state::ARM_ENABLED);
        }
        break;
    case Type::ROVER:
        states.Set(Capability_state::AUTO_MODE_ENABLED);
        states.Set(Capability_state::MANUAL_MODE_ENABLED);
        states.Set(Capability_state::RETURN_HOME_ENABLED);
        break;
    case Type::OTHER:;
    }
    Set_capability_states(states);
}
