// Copyright (c) 2017, Smart Projects Holdings Ltd
// All rights reserved.
// See LICENSE file for license details.

#include <ardupilot_vehicle.h>

const ugcs::vsm::Mavlink_demuxer::System_id Mavlink_vehicle::VSM_SYSTEM_ID = 1;

/* Reference Mavlink implementation (ArduPilot) source code
 * (as for 17-July-2013) has the following comment:
 *
 * "Currently we are not checking for correct compid since APM is not
 *  passing mavlink info to any subsystem.
 *  If it is addressed to our system ID we assume it is for us"
 *
 *  In other words, component ID is ignored when packet is received by
 *  APM. To make the situation even worse, all packets generated by APM
 *  has component ID of 1, which is a hard-coded value. Thats why here
 *  same default component ID is used for all operations.
 */
const ugcs::vsm::Mavlink_demuxer::Component_id Mavlink_vehicle::VSM_COMPONENT_ID = 1;
constexpr std::chrono::milliseconds Ardupilot_vehicle::RC_OVERRIDE_PERIOD;
constexpr std::chrono::milliseconds Ardupilot_vehicle::RC_OVERRIDE_TIMEOUT;
constexpr std::chrono::seconds Ardupilot_vehicle::HL_POLLING_PERIOD;

using namespace ugcs::vsm;

void
Ardupilot_vehicle::On_enable()
{
    // Get parameter values.
    Mavlink_vehicle::On_enable();
    read_version.version_handler = Read_version::Make_version_handler(
        &Ardupilot_vehicle::On_autopilot_version,
        Shared_from_this());

    // We need to understand only that FS_EKF_ACTION is supported.
    read_version.Enable();

    read_waypoints.item_handler = Read_waypoints::Make_mission_item_handler(
        &Ardupilot_vehicle::On_mission_item,
        Shared_from_this());

    read_waypoints.Set_next_action(
        Write_parameters::Make_next_action(
            &Ardupilot_vehicle::On_mission_downloaded,
            this));

    // Poll for home location until it becomes valid.
    home_location_timer =
        Timer_processor::Get_instance()->Create_timer(
            HL_POLLING_PERIOD,
            Make_callback(
                &Ardupilot_vehicle::On_home_location_timer,
                Shared_from_this()),
            Get_completion_ctx());

    mav_stream->Get_demuxer().Register_handler<mavlink::MESSAGE_ID::PARAM_VALUE, mavlink::Extension>(
        Mavlink_demuxer::Make_handler<mavlink::MESSAGE_ID::PARAM_VALUE, mavlink::Extension>(
            &Ardupilot_vehicle::On_parameter,
            Shared_from_this()),
        real_system_id);


    mav_stream->Get_demuxer().Register_handler<mavlink::sph::MESSAGE_ID::PARAM_STR_VALUE, mavlink::sph::Extension>(
        Mavlink_demuxer::Make_handler<mavlink::sph::MESSAGE_ID::PARAM_STR_VALUE, mavlink::sph::Extension>(
            &Ardupilot_vehicle::On_string_parameter,
            Shared_from_this()),
        real_system_id);


    mav_stream->Get_demuxer().Register_handler<mavlink::sph::SPH_ADSB_TRANSPONDER_STATE, mavlink::sph::Extension>(
        Mavlink_demuxer::Make_handler<mavlink::sph::SPH_ADSB_TRANSPONDER_STATE, mavlink::sph::Extension>(
            &Ardupilot_vehicle::On_adsb_state,
            Shared_from_this()),
        real_system_id);

    Download_mission();

    subsystems.adsb_transponder = Add_subdevice(SUBDEVICE_TYPE_ADSB_TRANSPONDER);

    c_adsb_set_mode = Add_command(subsystems.adsb_transponder, "adsb_set_mode", true, false);
    auto  p = c_adsb_set_mode->Add_parameter("mode", ugcs::vsm::proto::FIELD_SEMANTIC_ADSB_MODE);
    p->Add_enum("off", ugcs::vsm::proto::ADSB_MODE_OFF);
    p->Add_enum("on", ugcs::vsm::proto::ADSB_MODE_ON);
    p->Add_enum("stby", ugcs::vsm::proto::ADSB_MODE_STBY);
    p->Add_enum("alt", ugcs::vsm::proto::ADSB_MODE_ALT);

    c_adsb_set_parameter = Add_command(subsystems.adsb_transponder, "set_parameter", true, false);
    c_adsb_set_parameter->Add_parameter("adsb_icao", Property::VALUE_TYPE_INT);
    c_adsb_set_parameter->Add_parameter("adsb_squawk", proto::FIELD_SEMANTIC_SQUAWK);
    c_adsb_set_parameter->Add_parameter("adsb_registration", proto::FIELD_SEMANTIC_STRING);
    c_adsb_set_parameter->Add_parameter("adsb_flight_id", proto::FIELD_SEMANTIC_STRING);

    c_adsb_set_ident = Add_command(subsystems.adsb_transponder, "adsb_set_ident", true, false);

    c_set_fence->Set_available(true);
    c_set_fence->Set_enabled(true);

    c_trigger_calibration->Set_available(true);
    c_trigger_reboot->Set_available(true);

    c_transition_fixed = Add_command(subsystems.fc, "transition_fixed", false, true);
    c_transition_vtol = Add_command(subsystems.fc, "transition_vtol", false, true);

#define ADD_T(x, y) t_##x = Add_telemetry(subsystems.adsb_transponder, #x, y)
    ADD_T(adsb_altitude_internal, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL);
    ADD_T(adsb_icao, ugcs::vsm::proto::FIELD_SEMANTIC_ICAO);
    ADD_T(adsb_registration, ugcs::vsm::proto::FIELD_SEMANTIC_STRING);
    ADD_T(adsb_flight, ugcs::vsm::proto::FIELD_SEMANTIC_STRING);
#undef ADD_T

#define ADD_T(x, y, z) t_##x = Add_telemetry(subsystems.adsb_transponder, #x, y, z)
    // Set timeout for telemetry fields so they automatically
    // are set to N/A if no new data received for 5 seconds.
    ADD_T(adsb_altitude, ugcs::vsm::proto::FIELD_SEMANTIC_ALTITUDE_AMSL, 5);
    ADD_T(adsb_ident_active, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL, 5);
    ADD_T(adsb_squawk, ugcs::vsm::proto::FIELD_SEMANTIC_SQUAWK, 5);
    ADD_T(adsb_transponder_mode, ugcs::vsm::proto::FIELD_SEMANTIC_ADSB_MODE, 5);
    t_adsb_transponder_mode->Add_enum("off", ugcs::vsm::proto::ADSB_MODE_OFF);
    t_adsb_transponder_mode->Add_enum("on", ugcs::vsm::proto::ADSB_MODE_ON);
    t_adsb_transponder_mode->Add_enum("stby", ugcs::vsm::proto::ADSB_MODE_STBY);
    t_adsb_transponder_mode->Add_enum("alt", ugcs::vsm::proto::ADSB_MODE_ALT);
    ADD_T(adsb_error_xpdr, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL, 5);
    ADD_T(adsb_error_icao, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL, 5);
    ADD_T(adsb_error_gps, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL, 5);
    ADD_T(adsb_error_squitter, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL, 5);
    ADD_T(adsb_error_temperature, ugcs::vsm::proto::FIELD_SEMANTIC_BOOL, 5);
#undef ADD_T

    adsb_parameter_map.insert({"ADSB_ICAO_ID", t_adsb_icao});
    adsb_parameter_map.insert({"ADSB_ALT_SRC", t_adsb_altitude_internal});

    adsb_string_parameter_map.insert({"ADSB_FLIGHT", t_adsb_flight});
    adsb_string_parameter_map.insert({"ADSB_TAIL", t_adsb_registration});

    if (type == ugcs::vsm::mavlink::MAV_TYPE_FIXED_WING) {
        c_set_parameter = Add_command(subsystems.fc, "set_parameter", false, true);
        c_set_parameter->Add_parameter("landing_flare_altitude", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_flare_time", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("min_landing_pitch", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_flare_damp", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_approach_airspeed", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_speed_weighting", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("max_auto_flight_pitch", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("max_pitch", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("min_throttle", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_sink_rate", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("landing_rangefinder_enabled", Property::VALUE_TYPE_FLOAT);
        c_set_parameter->Add_parameter("min_rangefinder_distance", Property::VALUE_TYPE_FLOAT);

        Set_rc_loss_actions({
            proto::FAILSAFE_ACTION_RTH,
            proto::FAILSAFE_ACTION_CONTINUE
            });

    } else {
        Set_rc_loss_actions({
            proto::FAILSAFE_ACTION_RTH,
            proto::FAILSAFE_ACTION_CONTINUE,
            proto::FAILSAFE_ACTION_LAND
            });

        Set_gps_loss_actions({
            proto::FAILSAFE_ACTION_WAIT,
            proto::FAILSAFE_ACTION_LAND
            });
    }

    Set_low_battery_actions({
        proto::FAILSAFE_ACTION_RTH,
        proto::FAILSAFE_ACTION_CONTINUE
        });

    Set_parameters_from_properties("vehicle.ardupilot.parameter");
    read_parameters.Enable({"FENCE_ENABLE", "Q_ENABLE"});
}

bool
Ardupilot_vehicle::Verify_parameter(const std::string& name, float value, mavlink::MAV_PARAM_TYPE& type)
{
    if (name == "DISARM_DELAY") {
        if (value >= 0 && value <= 127) {
            type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            return true;
        } else {
            return false;
        }
    }

    // There is no logic in ardupilot firmware which takes MAV_PARAM_TYPE into account.
    // So we may use any type.
    // We add this for DDC case when we need to update arbitrary parameter among dozens of drones.
    // Old code is above, may be we remove it in the future.
    type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
    return true;
}

void
Ardupilot_vehicle::On_adsb_state(
    ugcs::vsm::mavlink::Message<
        ugcs::vsm::mavlink::sph::SPH_ADSB_TRANSPONDER_STATE,
        ugcs::vsm::mavlink::sph::Extension>::Ptr message)
{
    if (!adsb_transponder_type) {
        adsb_transponder_type = message->payload->type.Get();
        switch (*adsb_transponder_type) {
        case 2: // BCON
            VEHICLE_LOG_INF(*this, "ADSB transponder detected: BCON");
            c_adsb_set_mode->Set_enabled();
            c_adsb_set_mode->Set_available();
            c_adsb_set_parameter->Set_enabled();
            c_adsb_set_parameter->Set_available();
            read_parameters.Enable({"ADSB_ICAO_ID", "ADSB_ALT_SRC"});
            break;
        case 3: // Sagetech
            VEHICLE_LOG_INF(*this, "ADSB transponder detected: Sagetech");
            c_adsb_set_mode->Set_enabled();
            c_adsb_set_mode->Set_available();
            c_adsb_set_ident->Set_enabled();
            c_adsb_set_ident->Set_available();
            c_adsb_set_parameter->Set_enabled();
            c_adsb_set_parameter->Set_available();
            read_parameters.Enable({"ADSB_ICAO_ID", "ADSB_ALT_SRC"});
            read_string_parameters.Enable({"ADSB_FLIGHT", "ADSB_TAIL"});
            break;
        default:
            VEHICLE_LOG_INF(*this, "No ADSB transponder detected");
            return; // No transponder present.
        }
    }

    if (!message->payload->squawk_code.Is_reset()) {
        t_adsb_squawk->Set_value(message->payload->squawk_code.Get());
    }

    if (!message->payload->ident_active.Is_reset()) {
        t_adsb_ident_active->Set_value(message->payload->ident_active.Get());
    }

    if (!message->payload->altitude.Is_reset()) {
        t_adsb_altitude->Set_value(message->payload->altitude.Get());
    }

    if (!message->payload->error_flags.Is_reset()) {
        int f = message->payload->error_flags.Get();
        t_adsb_error_gps->Set_value(f & 0x01);
        t_adsb_error_icao->Set_value(f & 0x02);
        t_adsb_error_temperature->Set_value(f & 0x04);
        t_adsb_error_squitter->Set_value(f & 0x08);
        t_adsb_error_xpdr->Set_value(f & 0x10);
    }

    if (message->payload->altitude_source_internal.Is_reset()) {
        t_adsb_altitude_internal->Set_value_na();
    } else {
        t_adsb_altitude_internal->Set_value(message->payload->altitude_source_internal.Get());
    }

    if (message->payload->transponder_mode.Is_reset()) {
        t_adsb_transponder_mode->Set_value_na();
    } else {
        switch (message->payload->transponder_mode.Get()) {
        case mavlink::sph::ADSB_TRANSPONDER_MODE_ON:
            t_adsb_transponder_mode->Set_value(proto::ADSB_MODE_ON);
            break;
        case mavlink::sph::ADSB_TRANSPONDER_MODE_ALT:
            t_adsb_transponder_mode->Set_value(proto::ADSB_MODE_ALT);
            break;
        case mavlink::sph::ADSB_TRANSPONDER_MODE_STBY:
            t_adsb_transponder_mode->Set_value(proto::ADSB_MODE_STBY);
            break;
        case mavlink::sph::ADSB_TRANSPONDER_MODE_OFF:
            t_adsb_transponder_mode->Set_value(proto::ADSB_MODE_OFF);
            break;
        default:
            t_adsb_transponder_mode->Set_value_na();
            break;
        }
    }
    Commit_to_ucs();
}


void
Ardupilot_vehicle::Handle_ucs_command(
    Ucs_request::Ptr ucs_request)
{
    if (vehicle_command.vehicle_command_request || vehicle_command.ucs_request) {
        Command_failed(ucs_request, "Previous request in progress");
        return;
    }

    if (ucs_request->request.device_commands_size() == 0) {
        Command_failed(ucs_request, "No commands found", proto::STATUS_INVALID_COMMAND);
        return;
    }

    for (int c = 0; c < ucs_request->request.device_commands_size(); c++) {
        auto &vsm_cmd = ucs_request->request.device_commands(c);

        auto cmd = Get_command(vsm_cmd.command_id());

        if (    cmd != c_adsb_set_mode
            &&  cmd != c_adsb_set_parameter
            &&  cmd != c_adsb_set_ident
            &&  cmd != c_set_servo
            &&  cmd != c_set_fence
            &&  cmd != c_emergency_land
            &&  cmd != c_trigger_calibration
            &&  cmd != c_trigger_reboot
            &&  cmd != c_repeat_servo) {
            // Delegate it back to base class handler (old style).
            if (c == 0) {
                Vehicle::Handle_ucs_command(ucs_request);
            } else {
                Command_failed(ucs_request, "Unsupported command", proto::STATUS_INVALID_COMMAND);
            }
            return;
        }
    }

    vehicle_command.Disable("Internal error");
    vehicle_command.ucs_request = ucs_request;
    vehicle_command.Enable();
}

void
Ardupilot_vehicle::On_disable()
{
    vehicle_command.Disable("Vehicle disconnected");
    task_upload.Disable();
    home_location_timer->Cancel();
    if (rc_override_timer) {
        rc_override_timer->Cancel();
    }
    Mavlink_vehicle::On_disable();
}

void
Ardupilot_vehicle::On_autopilot_version(ugcs::vsm::mavlink::Pld_autopilot_version ver)
{
    int maj = (ver->flight_sw_version.Get() >> 24) & 0xff;
    int min = (ver->flight_sw_version.Get() >> 16) & 0xff;
    int patch = (ver->flight_sw_version.Get() >> 8) & 0xff;
    int type = (ver->flight_sw_version.Get() >> 0) & 0xff;
    VEHICLE_LOG_INF(*this, "Ardupilot version=%d.%d.%d, type=%d", maj, min, patch, type);

    if (ver->flight_sw_version.Get() >= ARDUPILOT_VERSION(3, 3, 1)) {
        use_ekf_action_as_gps_failsafe = true;
        send_home_position_as_mav_cmd = true;
    }

    if (ver->flight_sw_version.Get() >= ARDUPILOT_VERSION(3, 4, 0)) {
        gnd_alt_offset_allow = true;
    }


    /* Disable HOME_POSITION support because SITL does not report it if connected via UDP.
     * With TCP it does work fine, but UDP scenario is very important for testing.
     *
    if (ver->flight_sw_version.Get() >= ARDUPILOT_VERSION(3, 4, 0))
    {// This is a bug in ardupilot code when connected via UDP
        use_get_home_position = true;
        mav_stream->Get_demuxer().Register_handler<mavlink::MESSAGE_ID::HOME_POSITION, mavlink::Extension>(
            Mavlink_demuxer::Make_handler<mavlink::MESSAGE_ID::HOME_POSITION, mavlink::Extension>(
                &Ardupilot_vehicle::On_home_position,
                Shared_from_this()),
            real_system_id);
    }
    */
}

void
Ardupilot_vehicle::On_parameter(
    ugcs::vsm::mavlink::Message<mavlink::MESSAGE_ID::PARAM_VALUE>::Ptr m)
{
    const auto &name = m->payload->param_id.Get_string();
    auto i = adsb_parameter_map.find(name);
    if (i != adsb_parameter_map.end()) {
        i->second->Set_value(m->payload->param_value.Get());
    }
    if (name == "GND_ALT_OFFSET") {
        current_alt_offset = m->payload->param_value.Get();
    } else if (name == "FENCE_ENABLE") {
        t_fence_enabled->Set_value(m->payload->param_value.Get() != 0);
    } else if (name == "Q_ENABLE") {
        vtol_plane = (m->payload->param_value.Get() != 0);
        VEHICLE_LOG_INF(*this, "This is a VTOL vehicle");
        Add_status_message("This is a VTOL capable vehicle, takeoff and land commands will be translated to VTOL versions");
    }
    Commit_to_ucs();
}

void
Ardupilot_vehicle::On_string_parameter(
    mavlink::Message<
        mavlink::sph::MESSAGE_ID::PARAM_STR_VALUE,
        mavlink::sph::Extension>::Ptr message)
{
    auto i = adsb_string_parameter_map.find(message->payload->param_id.Get_string());
    if (i != adsb_string_parameter_map.end()) {
        i->second->Set_value(message->payload->param_value.Get_string());
        Commit_to_ucs();
    }
}

void
Ardupilot_vehicle::On_mission_item(ugcs::vsm::mavlink::Pld_mission_item mi)
{
    if (mi->seq == 0) {
        Report_home_location(mi->x * M_PI / 180, mi->y * M_PI / 180, mi->z.Get());
    } else {
        // Do not add home location to mission hash because:
        // 1) autopilot can report different HL than uploaded.
        // 2) Get_home_location must not interfere with current downloaded mission
        //    as it will invalidate the mission hash.
        current_command_map.Accumulate_route_id(Get_mission_item_hash(mi));
        VEHICLE_LOG_INF(*this,
            "Mission item %d command %d,\n"
            "  p1=%f p2=%f p3=%f p4=%f p5=%f p6=%f p7=%f",
            mi->seq.Get(),
            mi->command.Get(),
            mi->param1.Get(),
            mi->param2.Get(),
            mi->param3.Get(),
            mi->param4.Get(),
            mi->x.Get(), mi->y.Get(), mi->z.Get());
    }
    current_route.Add_item(mi);
}

void
Ardupilot_vehicle::On_home_position(
    ugcs::vsm::mavlink::Message<mavlink::MESSAGE_ID::HOME_POSITION>::Ptr hp)
{
    double lat = hp->payload->latitude.Get();
    double lon = hp->payload->longitude.Get();
    double alt = hp->payload->altitude.Get();
    Report_home_location((lat / 10000000) * M_PI / 180, (lon / 10000000) * M_PI / 180, alt / 1000);
}

void
Ardupilot_vehicle::Report_home_location(double lat, double lon, float alt)
{
    home_location.latitude = lat;
    home_location.longitude = lon;

    if (Is_home_position_valid()) {
        VEHICLE_LOG_INF(*this,
            "Got home position: x=%f, y=%f, z=%f. Setting altitude origin.",
            lat * 180 / M_PI, lon * 180 / M_PI, alt);
        t_home_latitude->Set_value(home_location.latitude);
        t_home_longitude->Set_value(home_location.longitude);
        t_home_altitude_amsl->Set_value(alt);
        Set_altitude_origin(alt);   // this calls Commit_to_ucs.
    }
}

void
Ardupilot_vehicle::On_mission_downloaded(bool ok, const std::string status)
{
    if (ok) {
        VEHICLE_LOG_DBG(*this, "Mission downloaded. mission_id=%08X", current_command_map.Get_route_id());
        t_current_mission_id->Set_value(current_command_map.Get_route_id());
    } else {
        VEHICLE_LOG_DBG(*this, "Mission download failed: %s", status.c_str());
        Add_status_message(status);
    }
    read_waypoints.Disable();
}

bool
Ardupilot_vehicle::Is_home_position_valid()
{
    return (home_location.latitude != 0) || (home_location.longitude != 0);
}

bool
Ardupilot_vehicle::On_home_location_timer()
{
    // Keep requesting HL until successful.
    if (!Is_home_position_valid()) {
        Get_home_location();
    }
    if (Get_completion_ctx()->Is_enabled()) {
        return true;
    }
    return false;
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_task_request::Handle request)
{
    if (read_waypoints.In_progress()) {
        request.Fail("Mission download in progress");
        return;
    }
    VEHICLE_LOG_INF((*this), "Starting to handle %zu tasks...", request->actions.size());
    ASSERT(!task_upload.request);
    task_upload.Disable();
    task_upload.Enable(request);
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_command_request::Handle request)
{
    if (vehicle_command.vehicle_command_request || vehicle_command.ucs_request) {
        request.Fail("Previous request in progress");
    } else {
        vehicle_command.Disable("Internal error");
        vehicle_command.vehicle_command_request = request;
        vehicle_command.Enable();
    }
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type() const
{
    return Get_type(Get_mav_type());
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type(ugcs::vsm::mavlink::MAV_TYPE type)
{
    switch (type) {
    case mavlink::MAV_TYPE::MAV_TYPE_QUADROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_HEXAROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_OCTOROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_TRICOPTER:
    case mavlink::MAV_TYPE::MAV_TYPE_HELICOPTER:
    case mavlink::MAV_TYPE::MAV_TYPE_COAXIAL:
        return Type::COPTER;
        break;
    // VTOL is a kind of plane in ardupilot world.
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_DUOROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_QUADROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_RESERVED2:
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_RESERVED3:
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_RESERVED4:
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_RESERVED5:
    case mavlink::MAV_TYPE::MAV_TYPE_VTOL_TILTROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_FIXED_WING:
        return Type::PLANE;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_GROUND_ROVER:
        return Type::ROVER;
        break;
    default:
        switch (static_cast<mavlink::ugcs::MAV_TYPE>(type)) {
            case mavlink::ugcs::MAV_TYPE::MAV_TYPE_IRIS:
                return Type::COPTER;
            default:
                break;
        }
        return Type::OTHER;
    }
}

bool
Ardupilot_vehicle::Vehicle_command_act::Try()
{
    if (!remaining_attempts--) {
        VEHICLE_LOG_WRN(vehicle, "Vehicle_command all attempts failed.");
        Disable("Vehicle_command all attempts failed.");
        return false;
    }

    if (cmd_messages.size()) {
        Send_message(*(cmd_messages.front()));

        auto cmd = cmd_messages.front();
        if (cmd->Get_id() == mavlink::apm::MESSAGE_ID::FENCE_POINT) {
            Schedule_verify_timer();
        } else {
            Schedule_timer();
        }
        VEHICLE_LOG_DBG(vehicle, "Sending to vehicle: %s", (*(cmd_messages.front())).Dump().c_str());
    } else {
        // Command list is empty, nothing to do.
        Disable("Command list empty");
    }

    return false;
}

bool
Ardupilot_vehicle::Vehicle_command_act::Try_verify_polyfence()
{
    if (cmd_messages.size()) {
        // for polygon geofence set message send message for verification
        auto cmd = cmd_messages.front();
        if (cmd->Get_id() == mavlink::apm::MESSAGE_ID::FENCE_POINT) {
            auto& payload = (*std::static_pointer_cast<mavlink::apm::Pld_fence_point>(cmd));
            int idx = payload->idx.Get();
            VEHICLE_LOG_DBG(vehicle, "Verify geofence for point %d", idx);
            ugcs::vsm::mavlink::apm::Pld_fence_fetch_point fetch_point;
            Fill_target_ids(fetch_point);
            fetch_point->idx = idx;
            Send_message(fetch_point);
        } else {
            VEHICLE_LOG_WRN(vehicle, "Cancel geofence verifying: last command was not FENCE_POINT");
        }

        // Schedule timer for next common command retry
        Schedule_timer();

    } else {
        // Command list is empty, nothing to do.
        Disable("Command list empty");
    }

    return false;
}

void
Ardupilot_vehicle::Vehicle_command_act::On_point_value(
        mavlink::Message<mavlink::apm::MESSAGE_ID::FENCE_POINT, ugcs::vsm::mavlink::apm::Extension>::Ptr message)
{
    auto cmd = cmd_messages.front();
    if (cmd->Get_id() != mavlink::apm::MESSAGE_ID::FENCE_POINT) {
        // current command is not fence point. Skip checking.
        return;
    }

    auto& payload = (*std::static_pointer_cast<mavlink::apm::Pld_fence_point>(cmd));
    int idx = payload->idx.Get();
    double lat = payload->lat.Get();
    double lng = payload->lng.Get();

    double message_lat = message->payload->lat.Get();
    double message_lng = message->payload->lng.Get();


    if (message->payload->idx.Get() != idx) {
        /* Not the point we requested.
         * Don't reschedule immediately, wait for retry timeout.
         */
        return;
    }

    double relativeError_lat = fabs((message_lat - lat) / lat);
    double relativeError_lng = fabs((message_lng - lng) / lng);
    if ((relativeError_lat > 0.0000002) || (relativeError_lng > 0.0000002)) {
        VEHICLE_LOG_WRN(vehicle, "Geofence point writing validation failed for point [%d]. Lat,Lng [%2.20f, %2.20f] "
                                "expected, but [%2.20f, %2.20f] received. Relative errors are [%2.10f, %2.10f] ",
                        idx,
                        lat,
                        lng,
                        message_lat,
                        message_lng,
                        relativeError_lat,
                        relativeError_lng);
        Try();
        return;
    }
    VEHICLE_LOG_DBG(vehicle,
        "Geofence point [%d:%2.16f, %2.16f] write verified successfully. Relative errors are [%2.10f, %2.10f].",
        message->payload->idx.Get(),
        message->payload->lat.Get(),
        message->payload->lng.Get(),
        relativeError_lat,
        relativeError_lng);
    /* Written OK. */

    Send_next_command();
}


void
Ardupilot_vehicle::Start_rc_override()
{
    if (rc_override == nullptr) {
        // Create rc_override message. timer will delete it when vehicle switched to other mode.
        rc_override = mavlink::Pld_rc_channels_override::Create();
        rc_override_timer = Timer_processor::Get_instance()->Create_timer(
            RC_OVERRIDE_PERIOD,
            Make_callback(&Ardupilot_vehicle::Send_rc_override_timer, Shared_from_this()),
            Get_completion_ctx());
    }
    rc_override_end_counter = RC_OVERRIDE_END_COUNT;
    // Set larger timeout when turning on joystick mode
    // to let client more time to understand that joystick commands must be sent, now.
    direct_vehicle_control_last_received =
        std::chrono::steady_clock::now() + RC_OVERRIDE_TIMEOUT;
    Set_rc_override(1500, 1500, 1500, 1500);
}

void
Ardupilot_vehicle::Set_rc_override(int p, int r, int t, int y)
{
    if (Is_rc_override_active()) {
        (*rc_override)->chan1_raw = p;
        (*rc_override)->chan2_raw = r;
        (*rc_override)->chan3_raw = t;
        (*rc_override)->chan4_raw = y;
    }
}

void
Ardupilot_vehicle::Stop_rc_override()
{
    if (Is_rc_override_active()) {
        Set_rc_override(0, 0, 0, 0);
        // initiate countdown
        rc_override_end_counter = RC_OVERRIDE_END_COUNT - 1;
    }
}

void
Ardupilot_vehicle::Send_rc_override()
{
    // Do not send
    if (rc_override) {
//        LOG("Direct vehicle %d %d %d %d",
//            (*rc_override)->chan1_raw.Get(),
//            (*rc_override)->chan2_raw.Get(),
//            (*rc_override)->chan3_raw.Get(),
//            (*rc_override)->chan4_raw.Get()
//            );
        mav_stream->Send_message(
                *rc_override,
                255,
                190,
                Mavlink_vehicle::WRITE_TIMEOUT,
                Make_timeout_callback(
                        &Mavlink_vehicle::Write_to_vehicle_timed_out,
                        Shared_from_this(),
                        mav_stream),
                Get_completion_ctx());

        rc_override_last_sent = std::chrono::steady_clock::now();
        if (rc_override_end_counter < RC_OVERRIDE_END_COUNT && rc_override_end_counter > 0) {
            rc_override_end_counter--;
        }
    }
}

bool
Ardupilot_vehicle::Is_rc_override_active()
{
    return (rc_override && rc_override_end_counter == RC_OVERRIDE_END_COUNT);
}

bool
Ardupilot_vehicle::Send_rc_override_timer()
{
    if (rc_override == nullptr) {
        return false;
    }

    auto now = std::chrono::steady_clock::now();

    if (now - direct_vehicle_control_last_received > RC_OVERRIDE_TIMEOUT) {
        // Automatically exit joystick mode if there are no control messages from ucs.
        Stop_rc_override();
    }

    if (now - rc_override_last_sent < RC_OVERRIDE_PERIOD) {
        // Do not spam radio link too much.
        return true;
    }

    Send_rc_override();

    if (rc_override_end_counter == 0) {
        // exiting joystick mode.
        rc_override = nullptr;
        return false;
    }
    return true;
}

void
Ardupilot_vehicle::Vehicle_command_act::Send_next_command()
{
    cmd_messages.pop_front();
    if (cmd_messages.size()) {
        // send next command in chain.
        remaining_attempts = try_count;

        auto cmd = cmd_messages.front();
        if (cmd->Get_id() == mavlink::apm::MESSAGE_ID::FENCE_POINT) {
            // check if fence already set equal to this point
            auto& payload = (*std::static_pointer_cast<mavlink::apm::Pld_fence_point>(cmd));
            int idx = payload->idx.Get();
            VEHICLE_LOG_DBG(vehicle, "Check current geofence value for point %d", idx);
            ugcs::vsm::mavlink::apm::Pld_fence_fetch_point fetch_point;
            Fill_target_ids(fetch_point);
            fetch_point->idx = idx;
            Send_message(fetch_point);

            Schedule_timer();
        } else {
            Send_message(*(cmd_messages.front()));
            Schedule_timer();
            VEHICLE_LOG_DBG(vehicle, "Sending to vehicle: %s", (*(cmd_messages.front())).Dump().c_str());
        }

    } else {
        // command chain succeeded.
        Disable_success();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_command_ack(
        mavlink::Message<mavlink::MESSAGE_ID::COMMAND_ACK>::Ptr message)
{
    VEHICLE_LOG_DBG(vehicle, "COMAMND_ACK for command %d, res=%d",
            message->payload->command.Get(), message->payload->result.Get());

    if (cmd_messages.size()) {
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        int command_id = cmd->Get_id();
        if (command_id == mavlink::MESSAGE_ID::COMMAND_LONG) {
            command_id = (*std::static_pointer_cast<mavlink::Pld_command_long>(cmd))->command.Get();
        }
        if (message->payload->command.Get() == command_id) {
            // This is a response to our command.
            if (message->payload->result == mavlink::MAV_RESULT::MAV_RESULT_ACCEPTED) {
                Send_next_command();
            } else {
                auto p = message->payload->result.Get();
                auto s = std::string("Result: ")
                    + std::to_string(p)
                    + " ("
                    + Mav_result_to_string(p)
                    + ")";
                auto e = vehicle.Get_failed_sensor_report();
                if (!e.empty()) {
                    s += std::string(", ") + e;
                }
                Disable(s);
            }
        }
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_mission_current(
        mavlink::Message<mavlink::MESSAGE_ID::MISSION_CURRENT>::Ptr message)
{
    if (cmd_messages.size()) {
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        int command_id = cmd->Get_id();
        if (command_id == mavlink::MESSAGE_ID::MISSION_SET_CURRENT) {
            int seq = (*std::static_pointer_cast<mavlink::Pld_mission_set_current>(cmd))->seq.Get();
            // Autopilot did change the current command.
            // > here because sometimes Ardupilot responds with current sequence == seq+1;
            if (message->payload->seq >= seq) {
                Send_next_command();
            }
        }
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_mission_ack(
        mavlink::Message<mavlink::MESSAGE_ID::MISSION_ACK>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "MISSION_ACK, result %d",
            message->payload->type.Get());

    if (cmd_messages.size()) {
        if (message->payload->type == mavlink::MAV_MISSION_RESULT::MAV_MISSION_ACCEPTED) {
            Send_next_command();
        } else {
            auto p = message->payload->type.Get();
            Disable("MISSION_ACK result: " + std::to_string(p) + " (" + Mav_mission_result_to_string(p).c_str() + ")");
        }
    } else {
        // We are not waiting for messages.
        Disable("Unexpected MISSION_ACK");
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_param_str_value(
    mavlink::Message<mavlink::sph::MESSAGE_ID::PARAM_STR_VALUE, ugcs::vsm::mavlink::sph::Extension>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "PARAM_STR_VALUE, %s", message->payload.Dump().c_str());

    if (cmd_messages.size()) {
        std::string param_name;
        std::string param_value;
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        auto& payload = (*std::static_pointer_cast<mavlink::sph::Pld_param_str_set>(cmd));
        switch (cmd->Get_id()) {
        case mavlink::sph::MESSAGE_ID::PARAM_STR_SET:
            param_name = payload->param_id.Get_string();
            if (message->payload->param_id.Get_string() == param_name) {
                param_value = payload->param_value.Get_string();
                if (message->payload->param_value.Get_string() == param_value) {
                    Send_next_command();
                } else {
                    Disable("PARAM_SET failed");
                }
            }
            break;
        }
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_param_value(
        mavlink::Message<mavlink::MESSAGE_ID::PARAM_VALUE>::Ptr message)
{
    VEHICLE_LOG_INF(vehicle, "PARAM_VALUE, %s", message->payload.Dump().c_str());

    if (cmd_messages.size()) {
        // we are waiting for response.
        auto cmd = cmd_messages.front();
        if (cmd->Get_id() == mavlink::MESSAGE_ID::PARAM_SET) {
            auto param_name = (*std::static_pointer_cast<mavlink::Pld_param_set>(cmd))->param_id.Get_string();
            auto param_value = (*std::static_pointer_cast<mavlink::Pld_param_set>(cmd))->param_value.Get();
            if (message->payload->param_id.Get_string() == param_name) {
                if (message->payload->param_value.Get() == param_value) {
                    Send_next_command();
                } else {
                    Disable("PARAM_SET failed");
                }
            }
        }
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::On_status_text(
        ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::STATUSTEXT>::Ptr)
{
    /* Assumed command execution started, so wait longer. */
    if (current_timeout < extended_retry_timeout) {
        current_timeout = extended_retry_timeout;
        VEHICLE_LOG_DBG(vehicle, "Command execution detected, "
                "now waiting longer for a command to finish...");
        /* Start a new longer timer. */
        Schedule_timer();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::Enable()
{
    if (ardu_vehicle.Get_type() == Type::OTHER) {
        Disable("Commands for unknown vehicles types are not supported.");
        return;
    }

    Register_mavlink_handler<mavlink::MESSAGE_ID::COMMAND_ACK>(
        &Vehicle_command_act::On_command_ack,
        this,
        Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::MESSAGE_ID::MISSION_ACK>(
        &Vehicle_command_act::On_mission_ack,
        this,
        Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::MESSAGE_ID::PARAM_VALUE>(
        &Vehicle_command_act::On_param_value,
        this,
        Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::MESSAGE_ID::MISSION_CURRENT>(
        &Vehicle_command_act::On_mission_current,
        this,
        Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::sph::MESSAGE_ID::PARAM_STR_VALUE, ugcs::vsm::mavlink::sph::Extension>(
        &Vehicle_command_act::On_param_str_value,
        this,
        Mavlink_demuxer::COMPONENT_ID_ANY);

    Register_mavlink_handler<mavlink::apm::MESSAGE_ID::FENCE_POINT, mavlink::apm::Extension>(
        &Vehicle_command_act::On_point_value,
        this,
        Mavlink_demuxer::COMPONENT_ID_ANY);

    remaining_attempts = try_count;
    current_timeout = retry_timeout;

    /* Create always, it will be assigned to cmd_message, if used. */
    auto cmd_long = mavlink::Pld_command_long::Create();
    mavlink::Pld_mission_item::Ptr cmd_mission_item;
    mavlink::Pld_set_mode::Ptr cmd_set_mode;
    mavlink::Pld_param_set::Ptr param;
    Fill_target_ids(*cmd_long);
    mavlink::apm::Pld_fence_point::Ptr cmd_fence_point;
    cmd_messages.clear();

    if (ucs_request) {
        for (int c = 0; c < ucs_request->request.device_commands_size(); c++) {
            auto &vsm_cmd = ucs_request->request.device_commands(c);

            auto cmd = vehicle.Get_command(vsm_cmd.command_id());

            VEHICLE_LOG_INF((vehicle), "COMMAND %s (%d) received",
                cmd->Get_name().c_str(),
                vsm_cmd.command_id());

            Property_list params;

            try {
                params = cmd->Build_parameter_list(vsm_cmd);
                if        (cmd == vehicle.c_adsb_set_mode) {
                    int mode;
                    if (params.Get_value("mode", mode)) {
                        (*cmd_long)->command = mavlink::sph::MAV_CMD_ADSB_SET_MODE;
                        switch (mode) {
                        case ugcs::vsm::proto::ADSB_MODE_OFF:
                            (*cmd_long)->param1 = mavlink::sph::ADSB_TRANSPONDER_MODE_OFF;
                            break;
                        case ugcs::vsm::proto::ADSB_MODE_ON:
                            (*cmd_long)->param1 = mavlink::sph::ADSB_TRANSPONDER_MODE_ON;
                            break;
                        case ugcs::vsm::proto::ADSB_MODE_STBY:
                            (*cmd_long)->param1 = mavlink::sph::ADSB_TRANSPONDER_MODE_STBY;
                            break;
                        case ugcs::vsm::proto::ADSB_MODE_ALT:
                            (*cmd_long)->param1 = mavlink::sph::ADSB_TRANSPONDER_MODE_ALT;
                            break;
                        default:
                            VSM_EXCEPTION(Invalid_param_exception, "Unsupported mode");
                        }
                        cmd_messages.emplace_back(cmd_long);
                    } else {
                        VSM_EXCEPTION(Invalid_param_exception, "Unsupported mode");
                    }

                } else if (cmd == vehicle.c_adsb_set_parameter) {
                    int int_value;
                    std::string str_value;
                    if (params.Get_value("adsb_icao", int_value)) {
                        param = mavlink::Pld_param_set::Create();
                        Fill_target_ids(*param);
                        (*param)->param_id = "ADSB_ICAO_ID";
                        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT32;
                        (*param)->param_value = int_value;
                        cmd_messages.emplace_back(param);
                    }
                    if (params.Get_value("adsb_squawk", int_value)) {
                        param = mavlink::Pld_param_set::Create();
                        Fill_target_ids(*param);
                        (*param)->param_id = "ADSB_SQUAWK";
                        (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT32;
                        (*param)->param_value = int_value;
                        cmd_messages.emplace_back(param);
                    }
                    if (params.Get_value("adsb_registration", str_value)) {
                        auto param = mavlink::sph::Pld_param_str_set::Create();
                        Fill_target_ids(*param);
                        (*param)->param_id = "ADSB_TAIL";
                        (*param)->param_value = str_value;
                        cmd_messages.emplace_back(param);
                    }
                    if (params.Get_value("adsb_flight_id", str_value)) {
                        auto param = mavlink::sph::Pld_param_str_set::Create();
                        Fill_target_ids(*param);
                        (*param)->param_id = "ADSB_FLIGHT";
                        (*param)->param_value = str_value;
                        cmd_messages.emplace_back(param);
                    }
                } else if (cmd == vehicle.c_adsb_set_ident) {
                    param = mavlink::Pld_param_set::Create();
                    Fill_target_ids(*param);
                    (*param)->param_id = "ADSB_IDENT";
                    (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT32;
                    (*param)->param_value = 1;
                    cmd_messages.emplace_back(param);
                } else if (cmd == vehicle.c_emergency_land) {
                    (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
                    (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
                    (*cmd_long)->param1 = 0; /* Do disarm. */
                    (*cmd_long)->param2 = DISARM_MAGIC_VALUE; // do hard disarm (even when copter is airborne)
                    cmd_messages.emplace_back(cmd_long);
                } else if (cmd == vehicle.c_set_servo) {
                    int servo_id;
                    int pwm;
                    params.Get_value("servo_id", servo_id);
                    params.Get_value("pwm", pwm);
                    (*cmd_long)->command = mavlink::MAV_CMD_DO_SET_SERVO;
                    (*cmd_long)->param1 = servo_id;
                    (*cmd_long)->param2 = pwm;
                    cmd_messages.emplace_back(cmd_long);
                } else if (cmd == vehicle.c_repeat_servo) {
                    int servo_id;
                    int pwm;
                    int count;
                    float delay;
                    params.Get_value("servo_id", servo_id);
                    params.Get_value("pwm", pwm);
                    params.Get_value("delay", delay);
                    params.Get_value("count", count);
                    (*cmd_long)->command = mavlink::MAV_CMD_DO_REPEAT_SERVO;
                    (*cmd_long)->param1 = servo_id;
                    (*cmd_long)->param2 = pwm;
                    (*cmd_long)->param3 = count;
                    if (delay < 0.2) {
                        (*cmd_long)->param4 = 0;
                    } else {
                        // Pixhawk does this slower than expected. Add coefficient.
                        (*cmd_long)->param4 = delay * 2 - 0.4;
                    }
                    cmd_messages.emplace_back(cmd_long);
                } else if (cmd == vehicle.c_set_fence) {
                    ugcs::vsm::proto::List_value lats, lngs;

                    /* bitmask, fence type
                       0: no fence
                       1 bit: altitude fence
                       2 bit: cicrle fence
                       3 bit: polygon fence (after ardupilot 3.4). */
                    int8_t fence_mask = 0;


                    bool polygon_data_is_correct = true;

                    if (params.Get_value("latitudes", lats) && params.Get_value("longitudes", lngs)) {
                        polygon_data_is_correct = false;
                        fence_mask |= 4;
                        int poly_size = lats.values_size();
                        VEHICLE_LOG_INF(vehicle, "Adding polygon fence, Polygon size = %d", poly_size);

                        // check if polygon data is correct
                        if (!ardu_vehicle.Is_home_position_valid()) {
                            // Need valid home location
                            vehicle.Command_failed(ucs_request,
                                                   "Polygon fence: home location is not valid.",
                                                   proto::STATUS_INVALID_PARAM);
                        } else if (poly_size != lngs.values_size()) {
                            // ERROR: non equal points number
                            vehicle.Command_failed(ucs_request,
                                                   "Polygon fence: non equal number of points in lists",
                                                   proto::STATUS_INVALID_PARAM);
                        } else if (poly_size < 4) {
                            // ERROR: too few points
                            vehicle.Command_failed(ucs_request,
                                                   "Polygon fence: need at last 4 points for polygon fence",
                                                   proto::STATUS_INVALID_PARAM);
                        } else if (poly_size > 84) {
                            // ERROR: too much points
                            vehicle.Command_failed(ucs_request,
                                                   "Polygon fence: need no more than 84 points for polygon fence",
                                                   proto::STATUS_INVALID_PARAM);
                        } else if (lats.values(0).double_value() !=  lats.values(poly_size-1).double_value() ||
                                   lngs.values(0).double_value() !=  lngs.values(poly_size-1).double_value()) {
                            // ERROR: first point mast be equal to last point in polygon description
                            vehicle.Command_failed(ucs_request,
                               "Polygon fence: first point mast be equal to last point in polygon description",
                               proto::STATUS_INVALID_PARAM);
                        } else if (Is_Outside_Polygon(ardu_vehicle.home_location.latitude,
                                                      ardu_vehicle.home_location.longitude,
                                                      lats, lngs)) {
                            // ERROR: home location mas be inside polygon
                            VEHICLE_LOG_INF(vehicle, "HOME LOCATION : %2.20f, %2.20f",
                                            ardu_vehicle.home_location.latitude,
                                            ardu_vehicle.home_location.longitude);

                            vehicle.Command_failed(ucs_request,
                                                   "Polygon fence: Home Location must be inside polygon",
                                                   proto::STATUS_INVALID_PARAM);
                        } else {
                            polygon_data_is_correct = true;
                            // check if all values are double
                            for (int i = 0; i < poly_size; i++) {
                                if (!(lats.values(i).has_double_value() && lngs.values(i).has_double_value())) {
                                    vehicle.Command_failed(ucs_request,
                                                           "Polygon fence: incorrect latitude and longitude values",
                                                           proto::STATUS_INVALID_PARAM);
                                    polygon_data_is_correct = false;
                                }
                            }

                            if (polygon_data_is_correct) {
                                // set fence size
                                param = mavlink::Pld_param_set::Create();
                                Fill_target_ids(*param);
                                (*param)->param_id = "FENCE_TOTAL";
                                (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                                // +1 cause fist point we send is returning point.
                                (*param)->param_value = poly_size + 1;
                                cmd_messages.emplace_back(param);

                                // zero-point: Virtual return point.
                                // Virtual - because Copter returns to land point
                                // and not to this "return point". But "return point" needs to be inside
                                // polygon anyway due to strange ardupilot logic. So we set return point
                                // to Home Location and check that it is inside polygon (earlier) with
                                // function Is_Outside_Polygon.
                                VEHICLE_LOG_INF(vehicle, "Virtual return point(0) : %2.20f, %2.20f",
                                                ardu_vehicle.home_location.latitude * 180.0f / M_PI,
                                                ardu_vehicle.home_location.longitude * 180.0f / M_PI);
                                cmd_fence_point = mavlink::apm::Pld_fence_point::Create();
                                Fill_target_ids(*cmd_fence_point);
                                (*cmd_fence_point)->lat = ardu_vehicle.home_location.latitude * 180.0f / M_PI;
                                (*cmd_fence_point)->lng = ardu_vehicle.home_location.longitude * 180.0f / M_PI;
                                (*cmd_fence_point)->count = poly_size;
                                (*cmd_fence_point)->idx = 0;
                                cmd_messages.emplace_back(cmd_fence_point);

                                VEHICLE_LOG_INF(vehicle, "POLYGON FENCE POINTS:");
                                for (int i = 0; i < poly_size; i++) {
                                    double lat = lats.values(i).double_value()* 180.0f / M_PI;
                                    double lng = lngs.values(i).double_value()* 180.0f / M_PI;
                                    VEHICLE_LOG_INF(vehicle, "%d : %2.20f, %2.20f", i, lat, lng);
                                    cmd_fence_point = mavlink::apm::Pld_fence_point::Create();
                                    Fill_target_ids(*cmd_fence_point);
                                    (*cmd_fence_point)->lat = lat;
                                    (*cmd_fence_point)->lng = lng;
                                    (*cmd_fence_point)->count = poly_size;
                                    (*cmd_fence_point)->idx = i + 1;
                                    cmd_messages.emplace_back(cmd_fence_point);
                                }
                                VEHICLE_LOG_INF(vehicle, "POLYGON FENCE POINTS END. All points was put to queue.");
                            }
                        }
                    }

                    // if polygon data is correct or empty
                    if (polygon_data_is_correct) {
                        float radius;
                        float altitude;
                        float altitude_origin;
                        if (params.Get_value("radius", radius)) {
                            fence_mask |= 2;
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_RADIUS";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                            (*param)->param_value = radius;
                            cmd_messages.emplace_back(param);
                        }
                        if (    params.Get_value("altitude_amsl", altitude)
                            &&  params.Get_value("altitude_origin", altitude_origin))
                        {
                            fence_mask |= 1;
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_ALT_MAX";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                            (*param)->param_value = altitude - altitude_origin;
                            cmd_messages.emplace_back(param);
                        }

                        if (fence_mask) {
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_MARGIN";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                            (*param)->param_value = 2;
                            cmd_messages.emplace_back(param);
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_ACTION";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                            (*param)->param_value = 1; // RTL
                            cmd_messages.emplace_back(param);
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_TYPE";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                            (*param)->param_value = fence_mask;
                            cmd_messages.emplace_back(param);
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_ENABLE";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                            (*param)->param_value = 1;
                            cmd_messages.emplace_back(param);
                        } else {
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_ENABLE";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                            (*param)->param_value = 0;
                            cmd_messages.emplace_back(param);
                            param = mavlink::Pld_param_set::Create();
                            Fill_target_ids(*param);
                            (*param)->param_id = "FENCE_TYPE";
                            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                            (*param)->param_value = 0;
                            cmd_messages.emplace_back(param);
                        }
                    }
                } else if (cmd == vehicle.c_trigger_calibration) {
                    // gyro (param1)
                    (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
                    (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_PREFLIGHT_CALIBRATION;
                    (*cmd_long)->param1 = 1;
                    cmd_messages.emplace_back(cmd_long);

                    // param2 not supported by ardupilot

                    // baro (param3)
                    cmd_long = mavlink::Pld_command_long::Create();
                    Fill_target_ids(*cmd_long);
                    (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
                    (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_PREFLIGHT_CALIBRATION;
                    (*cmd_long)->param3 = 1;
                    cmd_messages.emplace_back(cmd_long);

                    // skip radio calibration (param4) as it requires user interaction.

                    // skip accelerometer (param5) calibration as it requires vehicle to be level.

                    // skip compass (param6) calibration as it requires vehicle to be rotated manually.
                } else if (cmd == vehicle.c_trigger_reboot) {
                    // sanity check
                    if (ardu_vehicle.Is_armed() || ardu_vehicle.is_airborne) {
                        vehicle.Command_failed(ucs_request,
                                               "Reboot is denied. UAV is armed or airborne.",
                                               proto::STATUS_FAILED);
                    } else {
                        cmd_long = mavlink::Pld_command_long::Create();
                        Fill_target_ids(*cmd_long);
                        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
                        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_PREFLIGHT_REBOOT_SHUTDOWN;
                        (*cmd_long)->param1 = 1; // reboot;
                        cmd_messages.emplace_back(cmd_long);
                    }
                }
            } catch (const std::exception& ex) {
                vehicle.Command_failed(ucs_request, ex.what(), proto::STATUS_INVALID_PARAM);
            }
        }
    } else {
        double heading;
        float pitch;
        float yaw;
        switch (vehicle_command_request->Get_type()) {
        case Vehicle_command::Type::RESUME_MISSION:
            // Resume mission only if vehicle is in normal flight conditions
            if (ardu_vehicle.Is_armed() && ardu_vehicle.is_airborne) {
                if (vehicle.Is_flight_mode(proto::FLIGHT_MODE_HOLD)) {
                    int command_idx;
                    if (vehicle.t_current_command->Get_value(command_idx)) {
                        auto set_cur = mavlink::Pld_mission_set_current::Create();
                        Fill_target_ids(*set_cur);
                        (*set_cur)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
                        (*set_cur)->seq = command_idx + 1;
                        cmd_messages.emplace_back(set_cur);
                    }
                } else {
                    param = mavlink::Pld_param_set::Create();
                    Fill_target_ids(*param);
                    (*param)->param_id = "MIS_RESTART";
                    (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                    (*param)->param_value = 0;
                    cmd_messages.emplace_back(param);
                    (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
                    (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
                    cmd_messages.emplace_back(cmd_long);
                }
            } else {
                Disable("Vehicle is not in normal flight conditions to perform RESUME MISSION command.");
            }
            break;

        case Vehicle_command::Type::AUTO_MODE:
            ardu_vehicle.Stop_rc_override();
            param = mavlink::Pld_param_set::Create();
            Fill_target_ids(*param);
            (*param)->param_id = "MIS_RESTART";
            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            (*param)->param_value = 1;
            cmd_messages.emplace_back(param);
            (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
            (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
            cmd_messages.emplace_back(cmd_long);
            // Reset MIS_RESTART back to 0 so that next time user enters AUTO from
            // RC tx, vehicle continues mission instead of returning back to WP1.
            param = mavlink::Pld_param_set::Create();
            Fill_target_ids(*param);
            (*param)->param_id = "MIS_RESTART";
            (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            (*param)->param_value = 0;
            cmd_messages.emplace_back(param);
            break;

        case Vehicle_command::Type::MANUAL_MODE:
            /* Current Ardupilot firmware does not send responses to mode changes,
             * so just check the current mode as an indication of completed
             * request. */
            if (vehicle.Is_control_mode(proto::CONTROL_MODE_MANUAL)) {
                vehicle_command_request.Succeed();
            } else {
                cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
                Fill_target_system_id(*cmd_set_mode);
                (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
                (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
                cmd_messages.emplace_back(cmd_set_mode);
            }
            ardu_vehicle.Stop_rc_override();
            break;

        case Vehicle_command::Type::ARM:
            (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
            (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
            (*cmd_long)->param1 = 1; /* Do arm. */
            cmd_messages.emplace_back(cmd_long);
            Register_status_text();
            break;

        case Vehicle_command::Type::DISARM:
            (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
            (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
            (*cmd_long)->param1 = 0; /* Do disarm. */
            cmd_messages.emplace_back(cmd_long);
            break;

        case Vehicle_command::Type::PAUSE_MISSION:
            // If vehicle is in guided mode already then
            // briefly move into manual to reset current guided WP and then
            // switch back to guided so the vehicle hovers at current position.
            if (vehicle.Is_control_mode(proto::CONTROL_MODE_CLICK_GO)) {
                cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
                Fill_target_system_id(*cmd_set_mode);
                (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
                (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
                cmd_messages.emplace_back(cmd_set_mode);
            }
            // Enter GUIDED mode.
            cmd_set_mode = mavlink::Pld_set_mode::Create();
            (*cmd_set_mode)->target_system = vehicle.real_system_id;
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_guided_mode();
            cmd_messages.emplace_back(cmd_set_mode);
            break;

        case Vehicle_command::Type::GUIDED_MODE:
            // Enter GUIDED mode.
            ardu_vehicle.Stop_rc_override();
            cmd_set_mode = mavlink::Pld_set_mode::Create();
            (*cmd_set_mode)->target_system = vehicle.real_system_id;
            (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*cmd_set_mode)->custom_mode = Get_custom_guided_mode();
            cmd_messages.emplace_back(cmd_set_mode);
            break;

        case Vehicle_command::Type::WAYPOINT:
            // Does 4 things:
            // Enter guided mode if needed
            // Change current speed
            // Change yaw if needed
            // Got to WP
            if (!vehicle.Is_control_mode(proto::CONTROL_MODE_CLICK_GO)) {
                ardu_vehicle.Stop_rc_override();
                // Enter GUIDED mode.
                cmd_set_mode = mavlink::Pld_set_mode::Create();
                (*cmd_set_mode)->target_system = vehicle.real_system_id;
                (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
                (*cmd_set_mode)->custom_mode = Get_custom_guided_mode();
                cmd_messages.emplace_back(cmd_set_mode);
            }

            heading = vehicle_command_request->Get_heading();

            param = mavlink::Pld_param_set::Create();
            Fill_target_ids(*param);
            if (ardu_vehicle.Get_type() == Type::PLANE) {
                (*param)->param_id = "TRIM_ARSPD_CM";
                (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT32;
                (*param)->param_value = vehicle_command_request->Get_speed() * 100;
                cmd_messages.emplace_back(param);
            } else if (ardu_vehicle.Get_type() == Type::COPTER) {
                (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
                (*cmd_long)->param1 = vehicle_command_request->Get_speed();
                (*cmd_long)->param2 = vehicle_command_request->Get_speed();
                cmd_messages.emplace_back(cmd_long);

                (*param)->param_id = "WPNAV_SPEED";
                (*param)->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                (*param)->param_value = vehicle_command_request->Get_speed() * 100;
                cmd_messages.emplace_back(param);

                if (!std::isnan(heading)) {
                    // we have heading specified. turn first.
                    cmd_mission_item = mavlink::Pld_mission_item::Create();
                    Fill_target_ids(*cmd_mission_item);
                    (*cmd_mission_item)->current = 2;
                    (*cmd_mission_item)->frame = mavlink::MAV_FRAME_GLOBAL_RELATIVE_ALT;
                    (*cmd_mission_item)->autocontinue = 1;
                    (*cmd_mission_item)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
                    // yaw angle
                    (*cmd_mission_item)->param1 = heading * 180.0 / M_PI;
                    // Use default angular speed (AUTO_YAW_SLEW_RATE == 60 deg/s)
                    (*cmd_mission_item)->param2 = 0;
                    // absolute angle
                    (*cmd_mission_item)->param4 = 0;
                    cmd_messages.emplace_back(cmd_mission_item);
                }
            }

            cmd_mission_item = mavlink::Pld_mission_item::Create();
            Fill_target_ids(*cmd_mission_item);
            (*cmd_mission_item)->current = 2;
            (*cmd_mission_item)->frame = mavlink::MAV_FRAME_GLOBAL_RELATIVE_ALT;
            (*cmd_mission_item)->autocontinue = 1;
            (*cmd_mission_item)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
            (*cmd_mission_item)->param1 = 0; // hold time
            (*cmd_mission_item)->param2 = vehicle_command_request->Get_acceptance_radius(); // acct radius
            (*cmd_mission_item)->param3 = 0; // passby radius
            (*cmd_mission_item)->param4 = heading * 180.0 / M_PI; // yaw angle
            (*cmd_mission_item)->x = vehicle_command_request->Get_latitude() * 180.0 / M_PI;
            (*cmd_mission_item)->y = vehicle_command_request->Get_longitude() * 180.0 / M_PI;
            (*cmd_mission_item)->z =
                vehicle_command_request->Get_altitude() - vehicle_command_request->Get_takeoff_altitude();
            cmd_messages.emplace_back(cmd_mission_item);
            break;

        case Vehicle_command::Type::LAND:
            (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
            (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
            cmd_messages.emplace_back(cmd_long);
            break;

        case Vehicle_command::Type::JOYSTICK_CONTROL_MODE:
            if (vehicle.Is_control_mode(proto::CONTROL_MODE_JOYSTICK)) {
                vehicle_command_request.Succeed();
            } else {
                // Set vehicle in manual mode and start pushing RC_CHANNELS_OVERRIDE messages.
                cmd_set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
                Fill_target_system_id(*cmd_set_mode);
                (*cmd_set_mode)->base_mode = mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
                (*cmd_set_mode)->custom_mode = Get_custom_manual_mode();
                cmd_messages.emplace_back(cmd_set_mode);
            }
            ardu_vehicle.Start_rc_override();
            break;

        case Vehicle_command::Type::DIRECT_VEHICLE_CONTROL:
    //        LOG("Direct Vehicle (rpyt) %1.3f %1.3f %1.3f %1.3f",
    //            vehicle_command_request->Get_roll(),
    //            vehicle_command_request->Get_pitch(),
    //            vehicle_command_request->Get_yaw(),
    //            vehicle_command_request->Get_throttle()
    //            );
            if (!vehicle.Is_control_mode(proto::CONTROL_MODE_JOYSTICK)) {
                break;
            }
            ardu_vehicle.direct_vehicle_control_last_received = std::chrono::steady_clock::now();
            pitch = vehicle_command_request->Get_pitch();
            yaw = vehicle_command_request->Get_yaw();

            // Normalize axes depending on vehicle type.
            if (ardu_vehicle.Get_type() == Type::COPTER) {
                pitch = -pitch;         // pitch is reversed for copter.
                yaw = yaw * 0.4;    // yaw on copter is too sensitive.
            } else {
                yaw = -yaw;     // yaw is reversed for plane.
            }

            ardu_vehicle.Set_rc_override(
                (vehicle_command_request->Get_roll() * 500.0) + 1500,
                (pitch * 500.0) + 1500,
                (vehicle_command_request->Get_throttle() * 500.0) + 1500,
                (yaw * 500.0) + 1500);
            ardu_vehicle.Send_rc_override();
            break;

        case Vehicle_command::Type::DIRECT_PAYLOAD_CONTROL:
    //        LOG("Direct Payload %d (rpyz) %1.3f %1.3f %1.3f %1.3f",
    //            vehicle_command_request->Get_payload_id(),
    //            vehicle_command_request->Get_roll(),
    //            vehicle_command_request->Get_pitch(),
    //            vehicle_command_request->Get_yaw(),
    //            vehicle_command_request->Get_zoom()
    //            );
            break;

        case Vehicle_command::Type::RETURN_HOME:
            (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
            (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH;
            cmd_messages.emplace_back(cmd_long);
            break;

        default:
            break;
        }
    }
    Try();
}

void
Ardupilot_vehicle::Vehicle_command_act::Disable_success()
{
    if (vehicle_command_request) {
        vehicle_command_request.Succeed();
    }
    if (ucs_request) {
        vehicle.Command_succeeded(ucs_request);
        ucs_request = nullptr;
    }
    Disable("");
}

void
Ardupilot_vehicle::Vehicle_command_act::Disable(const std::string& status)
{
    Unregister_mavlink_handlers();
    Unregister_status_text();

    if (timer) {
        timer->Cancel();
        timer = nullptr;
    }

    if (vehicle_command_request) {
        vehicle_command_request.Fail(status);
    }
    if (ucs_request) {
        vehicle.Command_failed(ucs_request, status);
        ucs_request = nullptr;
    }

    Ardupilot_activity::Disable();
}

void
Ardupilot_vehicle::Vehicle_command_act::Schedule_timer()
{
    if (timer) {
        timer->Cancel();
    }
    timer = Timer_processor::Get_instance()->Create_timer(
                current_timeout,
                Make_callback(&Vehicle_command_act::Try, this),
                vehicle.Get_completion_ctx());
}

void
Ardupilot_vehicle::Vehicle_command_act::Schedule_verify_timer()
{
    if (timer) {
        timer->Cancel();
    }
    timer = Timer_processor::Get_instance()->Create_timer(
            current_timeout,
            Make_callback(&Vehicle_command_act::Try_verify_polyfence, this),
            vehicle.Get_completion_ctx());
}

void
Ardupilot_vehicle::Vehicle_command_act::Register_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Make_statustext_handler(
                    &Ardupilot_vehicle::Vehicle_command_act::On_status_text,
                    this);
}

void
Ardupilot_vehicle::Vehicle_command_act::Unregister_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Statustext_handler();
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_auto_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::AUTO);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::AUTO);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::AUTO);
    case Type::OTHER:
        break;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom auto mode.", ardu_vehicle.Get_type());
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_manual_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::LOITER);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::STABILIZE);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::MANUAL);
    case Type::OTHER:
        break;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom manual mode.", ardu_vehicle.Get_type());
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_guided_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::GUIDED);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::GUIDED);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::GUIDED);
    case Type::OTHER:
        break;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom manual mode.", ardu_vehicle.Get_type());
}

bool
Ardupilot_vehicle::Vehicle_command_act::Is_Outside_Polygon(
    double check_point_latitude,
    double check_point_longitude,
    proto::List_value lats,
    proto::List_value lngs)
{
    const uint16_t n = lats.values_size();
    unsigned i, j;
    bool outside = true;

    for (i = 0, j = n-1; i < n; j = i++) {
        if ((lngs.values(i).double_value() > check_point_longitude) ==
            (lngs.values(j).double_value() > check_point_longitude)) {
            continue;
        }

        const double dx1 = check_point_latitude - lats.values(i).double_value();
        const double dx2 = lats.values(j).double_value() - lats.values(i).double_value();
        const double dy1 = check_point_longitude - lngs.values(i).double_value();
        const double dy2 = lngs.values(j).double_value() - lngs.values(i).double_value();
        const int8_t dx1s = (dx1 < 0) ? -1 : 1;
        const int8_t dx2s = (dx2 < 0) ? -1 : 1;
        const int8_t dy1s = (dy1 < 0) ? -1 : 1;
        const int8_t dy2s = (dy2 < 0) ? -1 : 1;
        const int8_t m1 = dx1s * dy2s;
        const int8_t m2 = dx2s * dy1s;

        if (dy2 < 0) {
            if (m1 > m2) {
                outside = !outside;
            } else if (m1 < m2) {
                continue;
            } else if ( dx1 * dy2 > dx2 * dy1 ) {
                outside = !outside;
            }
        } else {
            if (m1 < m2) {
                outside = !outside;
            } else if (m1 > m2) {
                continue;
            } else if ( dx1 * dy2 < dx2 * dy1 ) {
                outside = !outside;
            }
        }
    }
    return outside;
}

void
Ardupilot_vehicle::Task_upload::Enable(Vehicle_task_request::Handle request)
{
    this->request = request;

    if (ardu_vehicle.send_home_position_as_mav_cmd) {
        // HL altitude becomes altitude origin.
        // Need to set at the very beginning as it is used to specify safe_altitude, too.
        request->Set_takeoff_altitude(request->Get_home_position_altitude());
    }

    Filter_actions();
    Prepare_task_attributes();

    // Use GND_ALT_OFFSET to calibrate amsl altitude on mission upload.
    // Do this when uploading on ardupilot versions => 3.4.0
    bool armed = true;
    if (vehicle.t_is_armed->Get_value(armed) && !armed && ardu_vehicle.gnd_alt_offset_allow) {
        vehicle.read_parameters.Disable();
        vehicle.read_parameters.Set_next_action(
                Read_parameters::Make_next_action(
                        &Task_upload::Upload_parameters,
                        this));
        vehicle.read_parameters.Enable({"GND_ALT_OFFSET"});
    } else {
        Upload_parameters(true, "");
    }
}

void
Ardupilot_vehicle::Task_upload::Upload_parameters(bool success, std::string error_msg)
{
    if (success) {
        vehicle.write_parameters.Disable();
        vehicle.write_parameters.Set_next_action(
                Write_parameters::Make_next_action(
                        &Task_upload::Task_atributes_uploaded,
                        this));
        vehicle.write_parameters.Enable(task_attributes);
    } else {
        if (error_msg.size()) {
            request.Fail(error_msg);
        } else {
            request.Fail("Could not read GND_ALT_OFFSET");
        }
        Disable();
    }
}

void
Ardupilot_vehicle::Task_upload::Task_atributes_uploaded(bool success, std::string error_msg)
{
    if (!success) {
        if (error_msg.size()) {
            request.Fail(error_msg);
        } else {
            request.Fail("Task attributes upload failed");
        }
        Disable();
        return;
    }

    if (ardu_vehicle.send_home_position_as_mav_cmd) {
        vehicle.do_commands.Disable();
        vehicle.do_commands.Set_next_action(
                Activity::Make_next_action(
                        &Task_upload::Task_commands_sent,
                        this));

        mavlink::Pld_command_long cmd;
        auto hl = request->Get_home_position().Get_geodetic();
        cmd->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
        cmd->param1 = 0; // use specified.
        cmd->param5 = hl.latitude * 180 / M_PI;
        cmd->param6 = hl.longitude * 180 / M_PI;
        cmd->param7 = hl.altitude;
        vehicle.do_commands.Enable({cmd});
    } else {
        Task_commands_sent(true);
    }
}

void
Ardupilot_vehicle::Task_upload::Task_commands_sent(bool success, std::string)
{
    if (!success) {
        request.Fail("Failed to set home location");
        Disable();
        return;
    }

    // New home location should be set by now.
    // invalidate current home location and timer handler will retrieve it again.
    ardu_vehicle.home_location.longitude = 0;
    ardu_vehicle.home_location.latitude = 0;

    // Invalidate the current mission_id.
    vehicle.t_current_mission_id->Set_value_na();

    Prepare_task();
    vehicle.mission_upload.Disable();
    vehicle.mission_upload.mission_items = std::move(prepared_actions);
    vehicle.mission_upload.Set_next_action(
            Activity::Make_next_action(
                    &Task_upload::Mission_uploaded,
                    this));
    vehicle.mission_upload.Enable();
}

void
Ardupilot_vehicle::Task_upload::Mission_uploaded(bool success, std::string error_msg)
{
    if (success) {
        LOG("Mission uploaded");
        // Download the route to generate mission_id (hash) so that it will
        // be exactly the same when we download the mission next time.
        vehicle.read_waypoints.Disable();
        vehicle.read_waypoints.Set_next_action(
                Activity::Make_next_action(
                        &Task_upload::Mission_downloaded,
                        this));
        vehicle.read_waypoints.Enable();
    } else {
        if (error_msg.size()) {
            request.Fail(error_msg);
        } else {
            request.Fail("Route upload failed");
        }
        Disable();
    }
}

void
Ardupilot_vehicle::Task_upload::Mission_downloaded(bool success, std::string error_msg)
{
    if (success) {
        LOG("Verified mission_id=%08X", vehicle.current_command_map.Get_route_id());
        vehicle.t_current_mission_id->Set_value(vehicle.current_command_map.Get_route_id());
        // Populate the command_map in response.
        vehicle.current_command_map.Fill_command_mapping_response(request->ucs_response);
        request.Succeed();
    } else {
        if (error_msg.size()) {
            vehicle.Add_status_message(error_msg);
            request.Fail(error_msg);
        } else {
            request.Fail("Route verification failed");
        }
    }
    Disable();
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_coords(
        mavlink::Pld_mission_item& msg,
        const Geodetic_tuple& tuple, double heading)
{
    msg->x = (tuple.latitude * 180.0) / M_PI;
    msg->y = (tuple.longitude * 180.0) / M_PI;
    /* Fixup absolute altitude - make them relative to
     * take-off altitude.
     */
    msg->z = tuple.altitude - request->Get_takeoff_altitude();
    msg->param4 = (heading * 180.0) / M_PI;
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_common(
        mavlink::Pld_mission_item& msg)
{
    ASSERT(vehicle.real_system_id != Mavlink_demuxer::SYSTEM_ID_ANY);

    Fill_target_ids(msg);
    msg->seq = prepared_actions.size();

    vehicle.current_route.Add_item(msg);
    vehicle.current_command_map.Add_command_mapping(msg->seq);

    /* APM firmware treats all altitudes as relative. Always. */
    msg->frame = mavlink::MAV_FRAME::MAV_FRAME_GLOBAL_RELATIVE_ALT;
    msg->current = 0;
    msg->autocontinue = 1;
}

void
Ardupilot_vehicle::Task_upload::On_disable()
{
    request.Fail("Upload canceled");
    vehicle.write_parameters.Disable();
    vehicle.mission_upload.Disable();
    prepared_actions.clear();
    task_attributes.clear();
    current_mission_poi.Disengage();
    current_mission_heading.Disengage();
    last_move_action = nullptr;
    first_mission_poi_set = false;
    restart_mission_poi = false;
    current_heading = 0;
    heading_to_this_wp = 0;
}

void
Ardupilot_vehicle::Task_upload::Filter_actions()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Filter_copter_actions();
        return;
    case Type::PLANE:
        Filter_plane_actions();
        return;
    case Type::ROVER:
        Filter_rover_actions();
        return;
    case Type::OTHER:
        Filter_other_actions();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d.",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Filter_copter_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_plane_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_rover_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_other_actions()
{
    /* Only move is supported. Safe. */
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::MOVE:
            iter++;
            continue;
        default:
            VEHICLE_LOG_WRN(vehicle, "Action type %d ignored.", static_cast<int>((*iter)->Get_type()));
            break;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task()
{
    prepared_actions.clear();
    vehicle.current_command_map.Reset();
    vehicle.current_route.Reset();

    /* Ardupilot waypoint at index zero is always treated as home position,
     * so ensure it is always present. In other words, real waypoint should not
     * be stored at zero index.
     */
    Set_home_action::Ptr set_home_action = Set_home_action::Create(
            false /* use specified. */,
            request->Get_home_position(),
            0 /* elevation. */);

    Prepare_action(set_home_action);

    bool first_set_home_found = false;
    bool takeoff_added = false;

    last_move_action = nullptr;
    for (auto& iter : request->actions) {
        vehicle.current_command_map.Set_current_command(iter->command_id);
        switch (iter->Get_type()) {
        case Action::Type::TAKEOFF:
            takeoff_added = true;
            break;
        case Action::Type::MOVE:
            if (!takeoff_added) {
                // First WP found without prior takeoff action.
                // Insert takeoff action on first WP.
                // Required for ArduCopter 3.4+ otherwise it fails AUTO command.
                auto to = iter->Get_action<Action::Type::MOVE>();
                VEHICLE_LOG_WRN(vehicle, "Auto-adding TAKEOFF action before 1st WP");
                mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
                if (ardu_vehicle.vtol_plane) {
                    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_VTOL_TAKEOFF;
                } else {
                    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_TAKEOFF;
                }
                (*mi)->param1 = 0; /* No data for pitch. */
                Fill_mavlink_mission_item_coords(*mi, to->position.Get_geodetic(), to->heading);
                Add_mission_item(mi);
                takeoff_added = true;
            }
            break;
        case Action::Type::SET_HOME:
            if (!first_set_home_found) {
                /* Skip first set_home, it has been already processed and put
                 * into waypoint index zero. */
                first_set_home_found = true;
                continue;
            }
            break;
        default:
            break;
        }
        Prepare_action(iter);
    }

    if (last_move_action) {
        Prepare_action(last_move_action);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task_attributes()
{
    task_attributes.clear();
    if (request->attributes == nullptr) {
        return;
    }
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Prepare_copter_task_attributes();
        return;
    case Type::PLANE:
        Prepare_plane_task_attributes();
        return;
    case Type::ROVER:
        Prepare_rover_task_attributes();
        return;
    case Type::OTHER:
        Prepare_other_task_attributes();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Prepare_copter_task_attributes()
{
    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    using Emerg = Task_attributes_action::Emergency_action;

    // Use GND_ALT_OFFSET to calibrate amsl altitude on mission upload.
    // Do this when uploading
    float current_alt;
    bool armed = true;
    if (    vehicle.t_altitude_amsl->Get_value(current_alt)
        &&  vehicle.t_is_armed->Get_value(armed)
        &&  !armed
        &&  ardu_vehicle.gnd_alt_offset_allow)
    {
        param->param_id = "GND_ALT_OFFSET";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
        if (ardu_vehicle.set_ground_alt_offset) {
            float hl_alt = request->Get_home_position_altitude();
            param->param_value = (hl_alt - current_alt) + ardu_vehicle.current_alt_offset;
        } else {
            param->param_value = 0;
        }
        task_attributes.push_back(param);
    }
    if (request->attributes->low_battery != Emerg::DO_NOT_CHANGE) {
        /* Battery failsafe. */
        param->param_id = "FS_BATT_ENABLE";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        switch (request->attributes->low_battery) {
        case Emerg::GO_HOME:
            param->param_value = 2;
            break;
        case Emerg::LAND:
            param->param_value = 1;
            break;
        case Emerg::WAIT:
            /* There is no support for such behavior. Override with land. */
            param->param_value = 1;
            break;
        case Emerg::CONTINUE:
            param->param_value = 0;
            break;
        case Emerg::DO_NOT_CHANGE:
            LOG_WARN("Invalid FS action for low battery");
            break;
        }
        task_attributes.push_back(param);
    }

    if (request->attributes->gnss_loss != Emerg::DO_NOT_CHANGE) {
        /* GNSS loss failsafe. */
        if (ardu_vehicle.use_ekf_action_as_gps_failsafe) {
            param->param_id = "FS_EKF_ACTION";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            switch (request->attributes->gnss_loss) {
            case Emerg::LAND:
                param->param_value = 1;
                break;
            case Emerg::WAIT:
                param->param_value = 2;
                break;
            default:
                LOG_WARN("Invalid FS action for GPS");
                break;
            }
        } else {
            param->param_id = "FS_GPS_ENABLE";
            param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
            switch (request->attributes->gnss_loss) {
            case Emerg::LAND:
                param->param_value = 3;
                break;
            case Emerg::WAIT:
                param->param_value = 2;
                break;
            default:
                LOG_WARN("Invalid FS action for GPS");
                break;
            }
        }
        task_attributes.push_back(param);
    }

    /* Radio Control loss failsafe. */
    if (request->attributes->rc_loss != Emerg::DO_NOT_CHANGE) {
        param->param_id = "FS_THR_ENABLE";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
        switch (request->attributes->rc_loss) {
        case Emerg::GO_HOME:
            param->param_value = 1;
            break;
        case Emerg::LAND:
            param->param_value = 3;
            break;
        case Emerg::WAIT:
            /* Wait not supported, do land. */
            param->param_value = 3;
            break;
        case Emerg::CONTINUE:
            /* Continue in auto, land in other modes. */
            param->param_value = 2;
            break;
        case Emerg::DO_NOT_CHANGE:
            LOG_WARN("Invalid FS action for RC loss");
            break;
        }
        task_attributes.push_back(param);
    }

    if (std::isnan(request->attributes->safe_altitude)) {
        VEHICLE_LOG_INF(vehicle, "Not setting RTH altitude");
    } else {
        int16_t safe_alt = (request->attributes->safe_altitude - request->Get_takeoff_altitude()) * 100;

        if (safe_alt < 100) {
            // Avoid landing.
            VEHICLE_LOG_WRN(vehicle, "Forcing safe altitude to 1m");
            safe_alt = 100;
        }
        /* RTL altitude. */
        param->param_id = "RTL_ALT";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
        param->param_value = safe_alt;
        task_attributes.push_back(param);

        /* RTL Final altitude. Set to the same as RTL_ALT.
         * This makes it hover after RTL. 0 would mean land.*/
        param->param_id = "RTL_ALT_FINAL";
        param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
        param->param_value = safe_alt;
        task_attributes.push_back(param);
    }

    /* Don't change yaw during auto mission, because there is an auto-POI
     * feature. Besides that, duplicated waypoints are used to implement
     * actions like panorama, so it is not desirable to change the yaw while
     * switching between waypoints sharing the same location. */
    param->param_id = "WP_YAW_BEHAVIOR";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Never change yaw. */
    task_attributes.push_back(param);

#if 0 /* Wait until supported. */
    /* Mount control mode. */
    param->param_id = "MNT_MODE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 2; /* Mavlink targeting. */
    task_attributes.push_back(param);
#endif

    param->param_id = "CAM_TRIGG_TYPE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Servo trigger type. */
    task_attributes.push_back(param);
}

void
Ardupilot_vehicle::Task_upload::Prepare_plane_task_attributes()
{
    /* Add plane specific task attributes */
    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    float v;    // All my parameters are float.
    for (auto & p : request->parameters) {
        if (p.second->Get_value(v)) {
            if        (p.first == "landing_flare_altitude") {
                param->param_id = "LAND_FLARE_ALT";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_flare_time") {
                param->param_id = "LAND_FLARE_SEC";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "min_landing_pitch") {
                param->param_id = "LAND_PITCH_CD";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
                param->param_value = static_cast<int16_t>(lround(v * 18000 / M_PI));
            } else if (p.first == "landing_flare_damp") {
                param->param_id = "TECS_LAND_DAMP";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_approach_airspeed") {
                param->param_id = "TECS_LAND_ARSPD";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_speed_weighting") {
                param->param_id = "TECS_LAND_SPDWGT";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "max_auto_flight_pitch") {
                param->param_id = "TECS_PITCH_MAX";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                param->param_value = static_cast<int8_t>(lround(v * 180 / M_PI));
            } else if (p.first == "max_pitch") {
                param->param_id = "LIM_PITCH_MAX";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
                param->param_value = static_cast<int16_t>(lround(v * 18000 / M_PI));
            } else if (p.first == "min_throttle") {
                param->param_id = "THR_MIN";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                param->param_value = static_cast<int8_t>(lround(v));
            } else if (p.first == "landing_sink_rate") {
                param->param_id = "TECS_LAND_SINK";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_REAL32;
                param->param_value = v;
            } else if (p.first == "landing_rangefinder_enabled") {
                param->param_id = "RNGFND_LANDING";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
                param->param_value = static_cast<int8_t>(lround(v));
            } else if (p.first == "min_rangefinder_distance") {
                param->param_id = "RNGFND_MIN_CM";
                param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT16;
                param->param_value = static_cast<int16_t>(lround(v * 100));
            } else {
                VEHICLE_LOG_WRN(vehicle, "Unsupported parameter %s received.", p.first.c_str());
            }
            task_attributes.push_back(param);
        } else {
            if (!p.second->Is_value_na()) {
                VEHICLE_LOG_WRN(vehicle, "Invalid value for parameter %s", p.first.c_str());
            }
        }
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_rover_task_attributes()
{
    /* Add rover specific task attributes */
}

void
Ardupilot_vehicle::Task_upload::Prepare_other_task_attributes()
{
    /* Stub. */
}

void
Ardupilot_vehicle::Task_upload::Prepare_action(Action::Ptr action)
{
    switch (action->Get_type()) {
    case Action::Type::MOVE:
        Prepare_move(action);
        return;
    case Action::Type::WAIT:
        Prepare_wait(action);
        return;
    case Action::Type::PAYLOAD_STEERING:
        Prepare_payload_steering(action);
        return;
    case Action::Type::TAKEOFF:
        Prepare_takeoff(action);
        return;
    case Action::Type::LANDING:
        Prepare_landing(action);
        return;
    case Action::Type::CHANGE_SPEED:
        Prepare_change_speed(action);
        return;
    case Action::Type::SET_HOME:
        Prepare_set_home(action);
        return;
    case Action::Type::POI:
        Prepare_POI(action);
        return;
    case Action::Type::HEADING:
        Prepare_heading(action);
        return;
    case Action::Type::PANORAMA:
        Prepare_panorama(action);
        return;
    case Action::Type::CAMERA_TRIGGER:
        Prepare_camera_trigger(action);
        return;
    case Action::Type::CAMERA_SERIES_BY_TIME:
        Prepare_camera_series_by_time(action);
        return;
    case Action::Type::CAMERA_SERIES_BY_DISTANCE:
        Prepare_camera_series_by_distance(action);
        return;
    case Action::Type::SET_SERVO:
        Prepare_set_servo(action);
        return;
    case Action::Type::REPEAT_SERVO:
        Prepare_repeat_servo(action);
        return;
    case Action::Type::VTOL_TRANSITION:
        Prepare_vtol_transition(action);
        return;
    default:
        VEHICLE_LOG_ERR(vehicle, "action %s not supported.", action->Get_name().c_str());
        break;
    }
}

void
Ardupilot_vehicle::Task_upload::Add_mission_item(mavlink::Pld_mission_item::Ptr mi)
{
    Fill_mavlink_mission_item_common(*mi);
    prepared_actions.push_back(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_move(Action::Ptr& action)
{
    /* Turn off camera series if active. */
    if (!camera_series_by_dist_active_in_wp) {
        if (camera_series_by_dist_active) {
            camera_series_by_dist_active = false;
            Camera_series_by_distance_action::Ptr a =
                action->Get_action<Action::Type::CAMERA_SERIES_BY_DISTANCE>();
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
            Add_mission_item(mi);
        }
    }
    if (!camera_series_by_time_active_in_wp) {
        if (camera_series_by_time_active) {
            camera_series_by_time_active = false;

            Camera_series_by_time_action::Ptr a =
                action->Get_action<Action::Type::CAMERA_SERIES_BY_TIME>();
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
            (*mi)->param1 = ardu_vehicle.camera_servo_idx;
            Add_mission_item(mi);
        }
    }
    camera_series_by_dist_active_in_wp = false;
    camera_series_by_time_active_in_wp = false;

    if (last_move_action) {
        auto from = last_move_action->Get_action<Action::Type::MOVE>();
        auto to = action->Get_action<Action::Type::MOVE>();
        float calculated_heading = from->position.Bearing(to->position);
        // Handle several waypoints at the same coords.
        if (!std::isnan(calculated_heading)) {
            calculated_heading = Normalize_angle_0_2pi(calculated_heading);
            heading_to_this_wp = calculated_heading;
        } else {
            // Use previously calculated heading_to_this_wp.
        }
    }

    if (current_mission_poi) {
        if (!first_mission_poi_set && (ardu_vehicle.auto_generate_mission_poi || restart_mission_poi)) {
            // Add automatic POI on each consecutive WP.
            LOG("Set AutoPOI");
            Add_mission_item(Build_roi_mission_item(*current_mission_poi));
        }
    } else {
        if (current_mission_heading) {
            // Set current heading as yaw angle.
            current_heading = *current_mission_heading;
        } else {
            if (ardu_vehicle.autoheading) {
                // Set heading to next waypoint as yaw angle.
                current_heading = heading_to_this_wp;
            }
        }
        if (last_move_action && ardu_vehicle.Get_type() == Type::COPTER
            && (current_mission_heading || ardu_vehicle.autoheading)) {
            // Autoheading is copter specific.
            LOG("Set Autoheading to %f", current_heading);
            Add_mission_item(Build_heading_mission_item(current_heading));
        }
    }

    Add_mission_item(Build_wp_mission_item(action));
    last_move_action = action;

    restart_mission_poi = false;
    first_mission_poi_set = false;
    current_mission_heading.Disengage();
}

void
Ardupilot_vehicle::Task_upload::Prepare_wait(Action::Ptr& action)
{
    /* Create additional waypoint on the current position to wait. */
    if (last_move_action) {
        first_mission_poi_set = false;
        restart_mission_poi = true;
        Wait_action::Ptr wa = action->Get_action<Action::Type::WAIT>();
        auto wp = Build_wp_mission_item(last_move_action);
        (*wp)->param1 = wa->wait_time;
        switch (ardu_vehicle.Get_type()) {
        case Type::COPTER:
            if (!current_mission_poi && ardu_vehicle.autoheading) {
                Add_mission_item(Build_heading_mission_item(
                        Normalize_angle_0_2pi(current_heading)));
            }
            if (wa->wait_time < 0) {
                (*wp)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LOITER_UNLIM;
            } else {
                (*wp)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LOITER_TIME;
            }
            break;
        case Type::PLANE:
            if (wa->wait_time < 0) {
                (*wp)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LOITER_UNLIM;
            } else {
                (*wp)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LOITER_TIME;
            }
            break;
        default:
            VEHICLE_LOG_WRN(vehicle, "Wait supported only by plane and copter");
            return;
        }
        Add_mission_item(wp);
    } else {
        VEHICLE_LOG_WRN(vehicle, "No move action before wait action, ignored.");
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_payload_steering(Action::Ptr&)
{
    ASSERT(false); /* Not implemented yet */
}

void
Ardupilot_vehicle::Task_upload::Prepare_takeoff(Action::Ptr& action)
{
    /* Ardupilot does not fly to the takeoff position after takeoff
     * is done. Add explicit waypoint after the takeoff command with
     * target coordinates.
     */
    auto takeoff = action->Get_action<Action::Type::TAKEOFF>();
    auto explicit_wp = Move_action::Create(
            takeoff->position,
            0,
            takeoff->acceptance_radius,
            0,
            takeoff->heading,
            takeoff->elevation);

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    if (ardu_vehicle.vtol_plane) {
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_VTOL_TAKEOFF;
    } else {
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_TAKEOFF;
    }
    (*mi)->param1 = 0; /* No data for pitch. */
    Fill_mavlink_mission_item_coords(*mi, takeoff->position.Get_geodetic(), takeoff->heading);
    Add_mission_item(mi);
    Prepare_action(explicit_wp);
}

void
Ardupilot_vehicle::Task_upload::Prepare_landing(Action::Ptr& action)
{
    /* Ardupilot does not take the altitude of the landing, so
     * add explicit waypoint guiding vehicle to the landing start
     * position.
     */
    auto land = action->Get_action<Action::Type::LANDING>();
    auto explicit_wp = Move_action::Create(
            land->position,
            0,
            land->acceptance_radius,
            0,
            land->heading,
            land->elevation);
    Prepare_action(explicit_wp);

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    if (ardu_vehicle.vtol_plane) {
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_VTOL_LAND;
    } else {
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
    }
    Fill_mavlink_mission_item_coords(*mi, land->position.Get_geodetic(), land->heading);
    Add_mission_item(mi);

    /* Don't duplicate waypoint if last action is land. */
    last_move_action = nullptr;
}

void
Ardupilot_vehicle::Task_upload::Prepare_set_servo(Action::Ptr& action)
{
    Set_servo_action::Ptr ssa = action->Get_action<Action::Type::SET_SERVO>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_SERVO;
    (*mi)->param1 = ssa->servo_id;
    (*mi)->param2 = ssa->pwm;
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_repeat_servo(Action::Ptr& action)
{
    Repeat_servo_action::Ptr ssa = action->Get_action<Action::Type::REPEAT_SERVO>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ssa->servo_id;
    (*mi)->param2 = ssa->pwm;
    (*mi)->param3 = ssa->count;
    if (ssa->period < 0.2) {
        (*mi)->param4 = 0;
    } else {
        // Pixhawk does this slower than expected. Add coefficient.
        (*mi)->param4 = ssa->period * 2 - 0.4;
    }
    Add_mission_item(mi);
}

void

Ardupilot_vehicle::Task_upload::Prepare_change_speed(Action::Ptr& action)
{
    Change_speed_action::Ptr la = action->Get_action<Action::Type::CHANGE_SPEED>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
    auto speed = hypot(la->speed, la->vertical_speed);
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        /* ArduCopter version up to 3.2 use p1 for speed and ignores p2.
         * ArduCopter version up to 3.2+ use p2 for speed and ignores p1.
         * So, we set both, here.
         * Later, if MAV_CMD_DO_CHANGE_SPEED handling changes
         * in ArduPilot we will need to implement FW version checking.
         */
        (*mi)->param1 = speed;
        (*mi)->param2 = speed;
        break;
    case Type::ROVER:
    default:
        /* Ground rover takes only airspeed into account, others seems to
         * take both, but we have only airspeed from UCS, so use only air. */
        (*mi)->param1 = 0; /* Airspeed. */
        (*mi)->param2 = speed;
        break;
    }

    (*mi)->param3 = -1; /* Throttle no change. */
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_set_home(Action::Ptr& action)
{
    Set_home_action::Ptr sa = action->Get_action<Action::Type::SET_HOME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
    (*mi)->param1 = sa->use_current_position ? 1 : 0;
    Fill_mavlink_mission_item_coords(*mi, sa->home_position.Get_geodetic(), 0);
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_POI(Action::Ptr& action)
{
    Poi_action::Ptr pa = action->Get_action<Action::Type::POI>();
    if (pa->active) {
        // Set up POI for succeeding waypoints.
        current_mission_poi = pa->position.Get_geodetic();
        Add_mission_item(Build_roi_mission_item(*current_mission_poi));
        first_mission_poi_set = true;
    } else {
        // Reset POI. Generate next WPs as heading from now on.
        current_mission_poi.Disengage();
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_heading(Action::Ptr& action)
{
    Heading_action::Ptr ha = action->Get_action<Action::Type::HEADING>();
    Add_mission_item(Build_heading_mission_item(ha->heading));
    current_heading = ha->heading;
    current_mission_heading = ha->heading;
    // Heading action terminates current POI.
    restart_mission_poi = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_series_by_distance(Action::Ptr& action)
{
    Camera_series_by_distance_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_SERIES_BY_DISTANCE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_CAM_TRIGG_DIST;
    (*mi)->param1 = a->interval;
    Add_mission_item(mi);
    camera_series_by_dist_active = true;
    camera_series_by_dist_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_series_by_time(Action::Ptr& action)
{
    Camera_series_by_time_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_SERIES_BY_TIME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    (*mi)->param3 = a->count ? *a->count : 0xffff;
    (*mi)->param4 = static_cast<float>(a->interval.count()) / 1000.0;
    Add_mission_item(mi);
    camera_series_by_time_active = true;
    camera_series_by_time_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_trigger(Action::Ptr& action)
{
    Camera_trigger_action::Ptr a =
        action->Get_action<Action::Type::CAMERA_TRIGGER>();
    if (a->state != Camera_trigger_action::State::SINGLE_PHOTO &&
        a->state != Camera_trigger_action::State::SERIAL_PHOTO) {
        VEHICLE_LOG_WRN(vehicle, "Unsupported camera trigger state %d ignored.", a->state);
        return;
    }
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    if (a->state == Camera_trigger_action::State::SINGLE_PHOTO) {
        (*mi)->param3 = 1;
        (*mi)->param4 = ardu_vehicle.camera_servo_time;
    } else {
        (*mi)->param3 = 0xffff;
        (*mi)->param4 = static_cast<float>(a->interval.count()) / 1000.0;
        camera_series_by_time_active = true;
        camera_series_by_time_active_in_wp = true;
    }
    Add_mission_item(mi);
    camera_series_by_time_active = true;
    camera_series_by_time_active_in_wp = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_vtol_transition(Action::Ptr& action)
{
    if (ardu_vehicle.vtol_plane) {
        auto a = action->Get_action<Action::Type::VTOL_TRANSITION>();
        mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_VTOL_TRANSITION;
        switch (a->mode) {
        case Vtol_transition_action::FIXED:
            (*mi)->param1 = mavlink::MAV_VTOL_STATE_FW;
            break;
        case Vtol_transition_action::VTOL:
            (*mi)->param1 = mavlink::MAV_VTOL_STATE_MC;
            break;
        }
        Add_mission_item(mi);
    } else {
        VEHICLE_LOG_WRN(vehicle, "VTOL transition not supported by vehicle. Ignored.");
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_panorama(Action::Ptr& action)
{
    Panorama_action::Ptr panorama = action->Get_action<Action::Type::PANORAMA>();

    if (!last_move_action) {
        VEHICLE_LOG_WRN(vehicle, "No previous move action found to generate panorama action, ignored.");
        return;
    }
//    LOG("Panorama angle=%f, speed=%f, step=%f, delay=%lu",
//            panorama->angle,
//            panorama->speed,
//            panorama->step,
//            panorama->delay.count()
//            );

    /* Panorama is always done in steps less then 180 degree to make sure that
     * turns over 180 degrees are supported.
     */
    double MAX_STEP = 3;
    double speed = std::abs(panorama->speed);
    if (speed == 0 || speed > 1) {
        speed = 1; /* 1 rad/second assumed max speed. */
    }

    float cur_angle = 0;
    float target_angle = std::abs(panorama->angle);
    float step = MAX_STEP;
    int delay = 0;
    // Set delay to slightly more than the calculated time.
    double panorama_duration = std::abs(panorama->angle) / speed + 3;

    switch (panorama->trigger_state) {
    case Panorama_action::Trigger_state::ON:
        break;
    case Panorama_action::Trigger_state::SERIAL:
        /* Per-sector delay. */
        delay = std::chrono::duration_cast<std::chrono::seconds>(panorama->delay).count();
        // non zero delay. Use step from action.
        step = std::abs(panorama->step);
        // Add some time the delay to make the turn.
        delay += step / speed + 2;
        // do not add the long pause waypoint at the end.
        panorama_duration = 0;
        break;
    }

    if (step == 0) {
        VEHICLE_LOG_WRN(vehicle, "Zero step angle, ignoring panorama.");
        return;
    }

    Add_mission_item(Build_heading_mission_item(current_heading));
    /* Create additional waypoint at the current position with wait to
     * stabilize before doing panorama. */
    auto waiter = Build_wp_mission_item(last_move_action);
    (*waiter)->param1 = 2; /* seconds. */
    Add_mission_item(waiter);

    // Set off the trigger
    Add_camera_trigger_item();

    while (cur_angle < target_angle) {
        if (cur_angle + step > target_angle) {
            step = target_angle - cur_angle;
        }

        float cur_step_angle = 0;
        while (cur_step_angle < step) {
            if (step > MAX_STEP) {
                cur_step_angle += MAX_STEP;
            } else {
                cur_step_angle += step;
            }
            if (cur_step_angle > step) {
                cur_step_angle = step;
            }
            float temp_heading = cur_angle + cur_step_angle;
            if (panorama->angle < 0) {
                temp_heading = -temp_heading;
            }
            Add_mission_item(Build_heading_mission_item(
                    Normalize_angle_0_2pi(current_heading + temp_heading),
                    speed));
        }
        if (delay) {
            waiter = Build_wp_mission_item(last_move_action);
            (*waiter)->param1 = delay;
            Add_mission_item(waiter);

            // Set off trigger
            Add_camera_trigger_item();
        }
        cur_angle += cur_step_angle;
    }
    if (panorama->angle > 0) {
        current_heading = Normalize_angle_0_2pi(current_heading + target_angle);
    } else {
        current_heading = Normalize_angle_0_2pi(current_heading - target_angle);
    }


    /* Create a waypoint with hold time slightly more than estimated
     * panorama duration. Used only with Trigger_state::ON.
     */
    if (panorama_duration) {
        VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is %f seconds.", panorama_duration);
        auto long_wait = Build_wp_mission_item(last_move_action);
        if (panorama_duration > 255) {
            VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is truncated to 255 seconds.");
            (*long_wait)->param1 = 255; /* Max possible wait for Ardupilot. */
        } else {
            (*long_wait)->param1 = panorama_duration;
        }
        Add_mission_item(long_wait);
        LOG("long_wait WP %f", panorama_duration);
    }
    // panorama action terminates current POI.
    restart_mission_poi = true;
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_control(Action::Ptr& action)
{
    Camera_control_action::Ptr cam_control =
            action->Get_action<Action::Type::CAMERA_CONTROL>();

    /* TODO wait until supported by Ardupilot. */
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL;
    Add_mission_item(mi);
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_heading_mission_item(
        float heading,
        float speed,
        bool absolute_angle,
        bool clockwise
        )
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
    (*mi)->param1 = (Normalize_angle_0_2pi(heading) * 180.0) / M_PI;
    (*mi)->param2 = (speed * 180) / M_PI;
    (*mi)->param3 = clockwise? 1: -1;       // Not implemented in AP.
    (*mi)->param4 = absolute_angle? 0: 1;   /* absolute angle. */
    return mi;
}

void
Ardupilot_vehicle::Task_upload::Add_camera_trigger_item()
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_REPEAT_SERVO;
    (*mi)->param1 = ardu_vehicle.camera_servo_idx;
    (*mi)->param2 = ardu_vehicle.camera_servo_pwm;
    (*mi)->param3 = 1;
    (*mi)->param4 = ardu_vehicle.camera_servo_time;
    Add_mission_item(mi);
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_roi_mission_item(const Geodetic_tuple& coords)
{
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_ROI;
    if (coords.latitude == 0 && coords.longitude == 0 && coords.altitude == 0)
    {
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_NONE;
    } else {
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_LOCATION;
    }
    Fill_mavlink_mission_item_coords(*mi, coords, 0);
    return mi;
}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_wp_mission_item(Action::Ptr& action)
{
    Move_action::Ptr ma = action->Get_action<Action::Type::MOVE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();

    if (ardu_vehicle.Get_type() == Type::COPTER) {
        switch (ma->turn_type) {
        case Move_action::TURN_TYPE_SPLINE:
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_SPLINE_WAYPOINT;
            break;
        default:
            VEHICLE_LOG_WRN(vehicle, "Invalid turn type: %d, defaulting to 'straight'.", ma->turn_type);
        case Move_action::TURN_TYPE_STRAIGHT:
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
            break;
        }
    } else {
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
    }
    (*mi)->param1 = ma->wait_time;
    /* Set acceptance radius to something reasonable. */
    if (ma->acceptance_radius < ACCEPTANCE_RADIUS_MIN) {
        (*mi)->param2 = ACCEPTANCE_RADIUS_MIN;
        VEHICLE_LOG_INF(vehicle, "Acceptance radius normalized from %f to %f",
                ma->acceptance_radius, (*mi)->param2.Get());
    } else {
        (*mi)->param2 = ma->acceptance_radius;
    }
    (*mi)->param3 = ma->loiter_orbit;
    Fill_mavlink_mission_item_coords(*mi, ma->position.Get_geodetic(), ma->heading);
    return mi;
}

void
Ardupilot_vehicle::Process_heartbeat(
            ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::HEARTBEAT>::Ptr message)
{
    auto new_mode = message->payload->custom_mode.Get();
    Sys_status::Control_mode control_mode = Map_control_mode(new_mode);
    Update_flight_mode(new_mode);

    if (current_native_flight_mode != static_cast<int>(new_mode)) {
        const char* name = Get_native_flight_mode_name(new_mode);
        VEHICLE_LOG_INF((*this),
            "Flight mode changed from %d to %s (%d)",
            static_cast<int>(current_native_flight_mode),
            name,
            static_cast<int>(new_mode));
        current_native_flight_mode = new_mode;
        t_native_flight_mode->Set_value(name);

        Add_status_message("Flight mode changed to " + std::string(name));
    }

    Sys_status::State state = Sys_status::State::DISARMED;
    if (message->payload->base_mode.Get() & mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED) {
        state = Sys_status::State::ARMED;
    }

    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - recent_connect);

    is_airborne = message->payload->system_status.Get() == mavlink::MAV_STATE_ACTIVE;

    Update_capabilities();
    Update_capability_states();
    Set_system_status(Sys_status(true, true, control_mode, state, uptime));
}

/** Map custom flight mode from the heartbeat to our flight mode. */
void
Ardupilot_vehicle::Update_flight_mode(int mode)
{
    switch (Get_type()) {
    case Type::COPTER:
        switch (static_cast<Copter_flight_mode>(mode)) {
        case Copter_flight_mode::AUTO:
            if (Is_current_command(mavlink::MAV_CMD_NAV_LOITER_UNLIM)) {
                current_flight_mode = proto::FLIGHT_MODE_HOLD;
            } else {
                current_flight_mode = proto::FLIGHT_MODE_WAYPOINTS;
            }
            break;
        case Copter_flight_mode::RTL:
            current_flight_mode = proto::FLIGHT_MODE_RTH;
            break;
        case Copter_flight_mode::LAND:
            current_flight_mode = proto::FLIGHT_MODE_LAND;
            break;
        default:
            current_flight_mode.Disengage();
        }
        break;
    case Type::ROVER:
        switch (static_cast<Rover_flight_mode>(mode)) {
        case Rover_flight_mode::AUTO:
            current_flight_mode = proto::FLIGHT_MODE_WAYPOINTS;
            break;
        case Rover_flight_mode::RTL:
            current_flight_mode = proto::FLIGHT_MODE_RTH;
            break;
        default:
            current_flight_mode.Disengage();
        }
        break;
    case Type::PLANE:
        switch (static_cast<Plane_flight_mode>(mode)) {
        case Plane_flight_mode::AUTO:
            current_flight_mode = proto::FLIGHT_MODE_WAYPOINTS;
            break;
        case Plane_flight_mode::RTL:
            current_flight_mode = proto::FLIGHT_MODE_RTH;
            break;
        default:
            current_flight_mode.Disengage();
        }
        break;
    default:
        current_flight_mode.Disengage();
        break;
    }
    if (current_flight_mode) {
        t_flight_mode->Set_value(*current_flight_mode);
    } else {
        t_flight_mode->Set_value_na();
    }
}

void
Ardupilot_vehicle::Get_home_location()
{
    if (use_get_home_position) {
        auto cmd_long = mavlink::Pld_command_long::Create();
        (*cmd_long)->target_system = real_system_id;
        (*cmd_long)->target_component = real_component_id;
        (*cmd_long)->command = mavlink::MAV_CMD_GET_HOME_POSITION;
        Send_message(*cmd_long);
    } else {
        read_waypoints.Get_home_location();
    }
}

void
Ardupilot_vehicle::Download_mission()
{
    if (!read_waypoints.In_progress()) {
        t_current_mission_id->Set_value_na();
        current_command_map.Reset();
        current_route.Reset();
        read_waypoints.Enable();
    }
}

void
Ardupilot_vehicle::Update_capabilities()
{
    switch (Get_type()) {
    case Type::COPTER:
        c_arm->Set_available(true);
        c_disarm->Set_available(true);
        c_waypoint->Set_available(true);
        c_auto->Set_available(true);
        c_guided->Set_available(true);
        c_manual->Set_available(true);
        c_pause->Set_available(true);
        c_resume->Set_available(true);
        c_rth->Set_available(true);
        c_set_servo->Set_available(true);
        c_repeat_servo->Set_available(true);
        // Copter has LAND and sometimes -- joystick.
        c_land_command->Set_available(true);
        c_joystick->Set_available(true);
        c_direct_vehicle_control->Set_available(Is_control_mode(proto::CONTROL_MODE_JOYSTICK));
        break;

    case Type::PLANE:
        c_arm->Set_available(true);
        c_disarm->Set_available(true);
        c_waypoint->Set_available(true);
        c_auto->Set_available(true);
        c_guided->Set_available(true);
        c_manual->Set_available(true);
        c_pause->Set_available(true);
        c_resume->Set_available(true);
        c_rth->Set_available(true);
        c_set_servo->Set_available(true);
        c_repeat_servo->Set_available(true);
        if (enable_joystick_control_for_fixed_wing) {
            c_joystick->Set_available(true);
            c_direct_vehicle_control->Set_available(Is_control_mode(proto::CONTROL_MODE_JOYSTICK));
        } else {
            c_joystick->Set_available(false);
            c_direct_vehicle_control->Set_available(false);
        }
        break;

    case Type::ROVER:
        c_auto->Set_available(true);
        c_manual->Set_available(true);
        c_rth->Set_available(true);
        break;

    case Type::OTHER:
        break;
    }
}

void
Ardupilot_vehicle::Configure()
{
    auto props = ugcs::vsm::Properties::Get_instance().get();
    camera_servo_idx = props->Get_int("vehicle.ardupilot.camera_servo_idx");
    camera_servo_pwm = props->Get_int("vehicle.ardupilot.camera_servo_pwm");
    camera_servo_time = props->Get_float("vehicle.ardupilot.camera_servo_time");
    if (props->Exists("vehicle.ardupilot.enable_joystick_control_for_fixed_wing")) {
        auto yes = props->Get("vehicle.ardupilot.enable_joystick_control_for_fixed_wing");
        if (yes == "yes") {
            LOG_INFO("Enabled joystick mode for fixed wing.");
            enable_joystick_control_for_fixed_wing = true;
        }
    }
    if (props->Exists("vehicle.ardupilot.report_relative_altitude")) {
        auto yes = props->Get("vehicle.ardupilot.report_relative_altitude");
        if (yes == "no") {
            report_relative_altitude = false;
            LOG_INFO("VSM will not report relative altitude.");
        } else if (yes == "yes") {
            report_relative_altitude = true;
            LOG_INFO("VSM will report relative altitude.");
        } else {
            LOG_ERR("Invalid value '%s' for report_relative_altitude", yes.c_str());
        }
    }
    if (props->Exists("vehicle.ardupilot.set_ground_alt_offset")) {
        auto yes = props->Get("vehicle.ardupilot.set_ground_alt_offset");
        if (yes == "no") {
            set_ground_alt_offset = false;
            LOG_INFO("VSM will set GND_ALT_OFFSET to zero during mission upload.");
        } else if (yes == "yes") {
            set_ground_alt_offset = true;
            LOG_INFO("VSM will calibrate GND_ALT_OFFSET during mission upload");
        } else {
            LOG_ERR("Invalid value '%s' for set_ground_alt_offset. "
                "VSM will calibrate GND_ALT_OFFSET during mission upload.",
                yes.c_str());
        }
    }

    if (props->Exists("vehicle.ardupilot.telemetry_rate")) {
        int rate = props->Get_int("vehicle.ardupilot.telemetry_rate");
        if (rate < 1) {
            rate = 1;
        } else if (rate > 50) {
            rate = 50;
        }
        VEHICLE_LOG_INF((*this), "Setting telemetry rate to %d", rate);
        telemetry_rate_hz = rate;
    }
    if (props->Exists("vehicle.ardupilot.autoheading")) {
        auto yes = props->Get("vehicle.ardupilot.autoheading");

        if (yes == "no") {
            autoheading = false;
        } else if (yes == "yes") {
            autoheading = true;
        } else {
            LOG_ERR("Invalid value '%s' for autoheading", yes.c_str());
        }

        if (autoheading) {
            VEHICLE_LOG_INF((*this), "Autoheading is on.");
        } else {
            VEHICLE_LOG_INF((*this), "Autoheading is off.");
        }
    }
}

void
Ardupilot_vehicle::Update_capability_states()
{
    c_manual->Set_enabled(!Is_control_mode(proto::CONTROL_MODE_MANUAL));
    c_disarm->Set_enabled(Is_armed() && !is_airborne);
    c_emergency_land->Set_enabled(Is_armed());
    c_takeoff_command->Set_enabled(Is_armed() && !is_airborne);

    // servo commands are always enabled.
    c_set_servo->Set_enabled(true);
    c_repeat_servo->Set_enabled(true);

    // Calibration possible only while on the ground.
    c_trigger_calibration->Set_enabled(!Is_armed() && !is_airborne);

    // Calibration possible only while on the ground.
    c_trigger_reboot->Set_enabled(!Is_armed() && !is_airborne);

    if (Is_armed() && is_airborne) {
        c_waypoint->Set_enabled(true);
        c_auto->Set_enabled(!Is_flight_mode(proto::FLIGHT_MODE_WAYPOINTS) && !Is_flight_mode(proto::FLIGHT_MODE_HOLD));
        c_guided->Set_enabled(!Is_control_mode(proto::CONTROL_MODE_CLICK_GO));
        c_land_command->Set_enabled(true);
        c_pause->Set_enabled(!Is_control_mode(proto::CONTROL_MODE_MANUAL) && !Is_flight_mode(proto::FLIGHT_MODE_HOLD));
        // - Disable resume when flight mode is auto except when in HOLD mode.
        // - Disable resume while on last mission item
        c_resume->Set_enabled(
                (!Is_control_mode(proto::CONTROL_MODE_AUTO) || Is_flight_mode(proto::FLIGHT_MODE_HOLD))
            &&  !Is_current_command_last());
        c_joystick->Set_enabled(!Is_control_mode(proto::CONTROL_MODE_JOYSTICK));
        c_direct_vehicle_control->Set_enabled(Is_control_mode(proto::CONTROL_MODE_JOYSTICK));
        c_rth->Set_enabled(true);
        c_arm->Set_enabled(false);
    } else {
        c_waypoint->Set_enabled(false);
        c_auto->Set_enabled(Is_armed());
        c_guided->Set_enabled(false);
        c_land_command->Set_enabled(false);
        c_joystick->Set_enabled(false);
        c_pause->Set_enabled(false);
        c_resume->Set_enabled(false);
        c_rth->Set_enabled(false);
        c_arm->Set_enabled(!Is_armed() && !Is_control_mode(proto::CONTROL_MODE_AUTO));
        c_direct_vehicle_control->Set_enabled(false);
    }
    Commit_to_ucs();
}

const char*
Ardupilot_vehicle::Get_native_flight_mode_name(int mode)
{
    switch (Get_type()) {
    case Type::COPTER:
        switch (static_cast<Copter_flight_mode>(mode)) {
        case Copter_flight_mode::STABILIZE:
            return "STABILIZE";
        case Copter_flight_mode::ACRO:
            return "ACRO";
        case Copter_flight_mode::ALT_HOLD:
            return "ALT_HOLD";
        case Copter_flight_mode::AUTO:
            return "AUTO";
        case Copter_flight_mode::GUIDED:
            return "GUIDED";
        case Copter_flight_mode::LOITER:
            return "LOITER";
        case Copter_flight_mode::RTL:
            return "RTL";
        case Copter_flight_mode::CIRCLE:
            return "CIRCLE";
        case Copter_flight_mode::LAND:
            return "LAND";
        case Copter_flight_mode::OF_LOITER:
            return "OF_LOITER";
        case Copter_flight_mode::DRIFT:
            return "DRIFT";
        case Copter_flight_mode::SPORT:
            return "SPORT";
        case Copter_flight_mode::FLIP:
            return "FLIP";
        case Copter_flight_mode::AUTOTUNE:
            return "AUTOTUNE";
        }
        break;
    case Type::ROVER:
        switch (static_cast<Rover_flight_mode>(mode)) {
        case Rover_flight_mode::MANUAL:
            return "MANUAL";
        case Rover_flight_mode::LEARNING:
            return "LEARNING";
        case Rover_flight_mode::STEERING:
            return "STEERING";
        case Rover_flight_mode::HOLD:
            return "HOLD";
        case Rover_flight_mode::AUTO:
            return "AUTO";
        case Rover_flight_mode::RTL:
            return "RTL";
        case Rover_flight_mode::GUIDED:
            return "GUIDED";
        case Rover_flight_mode::INITIALISING:
            return "INITIALISING";
        }
        break;
    case Type::PLANE:
        switch (static_cast<Plane_flight_mode>(mode)) {
        case Plane_flight_mode::MANUAL:
            return "MANUAL";
        case Plane_flight_mode::CIRCLE:
            return "CIRCLE";
        case Plane_flight_mode::STABILIZE:
            return "STABILIZE";
        case Plane_flight_mode::TRAINING:
            return "TRAINING";
        case Plane_flight_mode::ACRO:
            return "ACRO";
        case Plane_flight_mode::FLY_BY_WIRE_A:
            return "FLY_BY_WIRE_A";
        case Plane_flight_mode::FLY_BY_WIRE_B:
            return "FLY_BY_WIRE_B";
        case Plane_flight_mode::CRUISE:
            return "CRUISE";
        case Plane_flight_mode::AUTO:
            return "AUTO";
        case Plane_flight_mode::RTL:
            return "RTL";
        case Plane_flight_mode::LOITER:
            return "LOITER";
        case Plane_flight_mode::GUIDED:
            return "GUIDED";
        case Plane_flight_mode::INITIALISING:
            return "INITIALISING";
        }
        break;
    case Type::OTHER:
        break;
    }
    return nullptr;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_control_mode(int mode)
{
    switch (Get_type()) {
    case Type::COPTER:
        switch (static_cast<Copter_flight_mode>(mode)) {
        case Copter_flight_mode::GUIDED:
            return Sys_status::Control_mode::GUIDED;
        case Copter_flight_mode::AUTO:
        case Copter_flight_mode::RTL:
        case Copter_flight_mode::CIRCLE:
        case Copter_flight_mode::LAND:
        case Copter_flight_mode::AUTOTUNE:
            return Sys_status::Control_mode::AUTO;
        case Copter_flight_mode::STABILIZE:
        case Copter_flight_mode::ACRO:
        case Copter_flight_mode::ALT_HOLD:
        case Copter_flight_mode::OF_LOITER:
        case Copter_flight_mode::LOITER:
        case Copter_flight_mode::DRIFT:
        case Copter_flight_mode::SPORT:
        case Copter_flight_mode::FLIP:
            if (Is_rc_override_active()) {
                return Sys_status::Control_mode::JOYSTICK;
            } else {
                return Sys_status::Control_mode::MANUAL;
            }
        }
        break;
    case Type::ROVER:
        switch (static_cast<Rover_flight_mode>(mode)) {
        case Rover_flight_mode::AUTO:
        case Rover_flight_mode::RTL:
            return Sys_status::Control_mode::AUTO;
        case Rover_flight_mode::GUIDED:
            return Sys_status::Control_mode::GUIDED;
        case Rover_flight_mode::MANUAL:
        case Rover_flight_mode::LEARNING:
        case Rover_flight_mode::STEERING:
        case Rover_flight_mode::HOLD:
            if (Is_rc_override_active()) {
                return Sys_status::Control_mode::JOYSTICK;
            } else {
                return Sys_status::Control_mode::MANUAL;
            }
        case Rover_flight_mode::INITIALISING:
            break;
        /* Fall down to unknown. */
        }
        break;
    case Type::PLANE:
        switch (static_cast<Plane_flight_mode>(mode)) {
        case Plane_flight_mode::AUTO:
        case Plane_flight_mode::LOITER:
        case Plane_flight_mode::CIRCLE:
        case Plane_flight_mode::RTL:
            return Sys_status::Control_mode::AUTO;
        case Plane_flight_mode::GUIDED:
            return Sys_status::Control_mode::GUIDED;
        case Plane_flight_mode::MANUAL:
        case Plane_flight_mode::STABILIZE:
        case Plane_flight_mode::TRAINING:
        case Plane_flight_mode::ACRO:
        case Plane_flight_mode::FLY_BY_WIRE_A:
        case Plane_flight_mode::FLY_BY_WIRE_B:
        case Plane_flight_mode::CRUISE:
            if (Is_rc_override_active()) {
                return Sys_status::Control_mode::JOYSTICK;
            } else {
                return Sys_status::Control_mode::MANUAL;
            }
        case Plane_flight_mode::INITIALISING:
            break;
            /* Fall down to unknown. */
        }
        break;
    case Type::OTHER:
        break;
    }
    return Sys_status::Control_mode::UNKNOWN;
}

