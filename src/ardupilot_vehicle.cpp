// Copyright (c) 2014, Smart Projects Holdings Ltd
// All rights reserved.
// See LICENSE file for license details.

#include <ardupilot_vehicle.h>

const ugcs::vsm::Mavlink_demuxer::System_id Mavlink_vehicle::VSM_SYSTEM_ID = 1;

/* Reference Mavlink implementation (ArduPilot) source code
 * (as for 17-July-2013) has the following comment:
 *
 * "Currently we are not checking for correct compid since APM is not
 *  passing mavlink info to any subsystem.
 *  If it is addressed to our system ID we assume it is for us"
 *
 *  In other words, component ID is ignored when packet is received by
 *  APM. To make the situation even worse, all packets generated by APM
 *  has component ID of 1, which is a hard-coded value. Thats why here
 *  same default component ID is used for all operations.
 */
const ugcs::vsm::Mavlink_demuxer::Component_id Mavlink_vehicle::VSM_COMPONENT_ID = 1;

using namespace ugcs::vsm;

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_task_request::Handle request)
{
    VEHICLE_LOG_INF((*this), "Starting to handle %zu tasks...", request->actions.size());
    ASSERT(!task_upload.request);
    task_upload.Disable();
    clear_all_missions.Disable();
    /* Mission upload will be done after all existing missions are cleared. */
    clear_all_missions.Set_next_action(
            Activity::Make_next_action(
                    &Task_upload::Enable,
                    &task_upload,
                    request));
    clear_all_missions.Enable(ugcs::vsm::Clear_all_missions());
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_clear_all_missions_request::Handle request)
{
    ASSERT(!task_upload.request);
    clear_all_missions.Disable();
    /* Only clear. */
    clear_all_missions.Enable(*request);
}

void
Ardupilot_vehicle::Handle_vehicle_request(Vehicle_command_request::Handle request)
{
    ASSERT(!vehicle_command.vehicle_command_request);
    vehicle_command.Disable();
    vehicle_command.Enable(request);
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type() const
{
    return Get_type(Get_mav_type());
}

Ardupilot_vehicle::Type
Ardupilot_vehicle::Get_type(ugcs::vsm::mavlink::MAV_TYPE type)
{
    switch (type) {
    case mavlink::MAV_TYPE::MAV_TYPE_QUADROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_HEXAROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_OCTOROTOR:
    case mavlink::MAV_TYPE::MAV_TYPE_TRICOPTER:
        return Type::COPTER;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_FIXED_WING:
        return Type::PLANE;
        break;
    case mavlink::MAV_TYPE::MAV_TYPE_GROUND_ROVER:
        return Type::ROVER;
        break;
    default:
        return Type::OTHER;
    }
}

bool
Ardupilot_vehicle::Vehicle_command_act::Try()
{
    if (!remaining_attempts--) {
        VEHICLE_LOG_WRN(vehicle, "Vehicle_command all attempts failed.");
        Disable();
        return false;
    }

    current_timeout = RETRY_TIMEOUT_SHORT;

    /* Create always, it will be assigned to cmd_message, if used. */
    cmd_long = mavlink::Pld_command_long::Create();
    Fill_target_ids(*cmd_long);

    switch (vehicle_command_request->Get_type()) {
    case Vehicle_command::Type::AUTO_MODE:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_MISSION_START;
        cmd_message = cmd_long;
        break;
    case Vehicle_command::Type::MANUAL_MODE: {
            /* Current Ardupilot firmware does not send responses to mode changes,
             * so just check the current mode as an indication of completed
             * request. */
            if (vehicle.Get_system_status().control_mode == Sys_status::Control_mode::MANUAL) {
                vehicle_command_request = Vehicle_request::Result::OK;
                Disable();
                return false;
            }
            auto set_mode = ugcs::vsm::mavlink::Pld_set_mode::Create();
            Fill_target_system_id(*set_mode);
            (*set_mode)->base_mode = ugcs::vsm::mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
            (*set_mode)->custom_mode = Get_custom_manual_mode();
            cmd_message = set_mode;
        }
        break;
    case Vehicle_command::Type::ARM:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
        (*cmd_long)->param1 = 1; /* Do arm. */
        cmd_message = cmd_long;
        Register_status_text();
        break;
    case Vehicle_command::Type::DISARM:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_COMPONENT_ARM_DISARM;
        (*cmd_long)->param1 = 0; /* Do disarm. */
        cmd_message = cmd_long;
        break;
    case Vehicle_command::Type::LAND:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
        cmd_message = cmd_long;
        break;
    case Vehicle_command::Type::RETURN_HOME:
        (*cmd_long)->target_component = mavlink::MAV_COMPONENT::MAV_COMP_ID_SYSTEM_CONTROL;
        (*cmd_long)->command = mavlink::MAV_CMD::MAV_CMD_NAV_RETURN_TO_LAUNCH;
        cmd_message = cmd_long;
        break;
    default:
        Disable();
        return false;
    }

    Send_message(*cmd_message);
    Schedule_timer();
    VEHICLE_LOG_DBG(vehicle, "Sending command [%s].", cmd_message->Get_name());
    return false;
}

void
Ardupilot_vehicle::Vehicle_command_act::On_command_ack(
        mavlink::Message<mavlink::MESSAGE_ID::COMMAND_ACK>::Ptr message)
{
    /* Is it a response to command long? */
    if (cmd_long->Get_id() == cmd_message->Get_id()) {
        if (message->payload->command != (*cmd_long)->command) {
            /* Not for us, ignore. */
            return;
        }
    } else {
        if (message->payload->command != cmd_message->Get_id()) {
            /* Not for us, ignore. */
            return;
        }
    }

    VEHICLE_LOG_INF(vehicle, "Vehicle command [%s] executed, result %d",
            cmd_message->Get_name(),
            message->payload->result.Get());

    if (message->payload->result == mavlink::MAV_RESULT::MAV_RESULT_ACCEPTED) {
        vehicle_command_request = Vehicle_request::Result::OK;
    } else {
        vehicle_command_request = Vehicle_request::Result::NOK;
    }
    Disable();
}

void
Ardupilot_vehicle::Vehicle_command_act::On_status_text(
        ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::STATUSTEXT>::Ptr)
{
    /* Assumed command execution started, so wait longer. */
    if (current_timeout != RETRY_TIMEOUT_LONG) {
        current_timeout = RETRY_TIMEOUT_LONG;
        VEHICLE_LOG_DBG(vehicle, "Command execution detected, "
                "now waiting longer for a command to finish...");
        /* Start a new longer timer. */
        Schedule_timer();
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::Enable(
        Vehicle_command_request::Handle vehicle_command_request)
{
    this->vehicle_command_request = vehicle_command_request;

    if (ardu_vehicle.Get_type() == Type::OTHER) {
        /* Commands for unknown vehicles types are not supported. */
        Disable();
        return;
    }

    remaining_attempts = ATTEMPTS;

    Register_mavlink_handler<mavlink::MESSAGE_ID::COMMAND_ACK>(
            &Vehicle_command_act::On_command_ack,
            this,
            Mavlink_demuxer::COMPONENT_ID_ANY);

    Try();
}

void
Ardupilot_vehicle::Vehicle_command_act::On_disable()
{
    Unregister_mavlink_handlers();
    Unregister_status_text();

    if (timer) {
        timer->Cancel();
        timer = nullptr;
    }
    if (vehicle_command_request) {
        vehicle_command_request = Vehicle_request::Result::NOK;
    }
}

void
Ardupilot_vehicle::Vehicle_command_act::Schedule_timer()
{
    if (timer) {
        timer->Cancel();
    }
    timer = Timer_processor::Get_instance()->Create_timer(
                std::chrono::seconds(current_timeout),
                Make_callback(&Vehicle_command_act::Try, this),
                vehicle.Get_completion_ctx());
}

void
Ardupilot_vehicle::Vehicle_command_act::Register_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Make_statustext_handler(
                    &Ardupilot_vehicle::Vehicle_command_act::On_status_text,
                    this);
}

void
Ardupilot_vehicle::Vehicle_command_act::Unregister_status_text()
{
    vehicle.statistics.statustext_handler =
            Mavlink_vehicle::Statistics::Statustext_handler();
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_auto_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::AUTO);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::AUTO);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::AUTO);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom auto mode.", ardu_vehicle.Get_type());
}

uint32_t
Ardupilot_vehicle::Vehicle_command_act::Get_custom_manual_mode()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        return static_cast<uint32_t>(Copter_flight_mode::LOITER);
    case Type::PLANE:
        return static_cast<uint32_t>(Plane_flight_mode::MANUAL);
    case Type::ROVER:
        return static_cast<uint32_t>(Rover_flight_mode::MANUAL);
    case Type::OTHER:;
    }
    VSM_EXCEPTION(Internal_error_exception,
            "Unsupported type %d of vehicle in custom manual mode.", ardu_vehicle.Get_type());
}


void
Ardupilot_vehicle::Task_upload::Enable(
        bool success,
        Vehicle_task_request::Handle request)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Previous activity failed, failing also task upload.");
        request = Vehicle_request::Result::NOK;
        Disable();
        return;
    }
    this->request = request;

    Filter_actions();
    Prepare_task_attributes();

    vehicle.write_parameters.Disable();
    vehicle.write_parameters.Set_next_action(
            Write_parameters::Make_next_action(
                    &Task_upload::Task_atributes_uploaded,
                    this));
    vehicle.write_parameters.Enable(task_attributes);
}

void
Ardupilot_vehicle::Task_upload::Task_atributes_uploaded(bool success)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Task attributes upload failed, failing task upload also.");
        Disable();
        return;
    }

    Prepare_task();
    vehicle.mission_upload.Disable();
    vehicle.mission_upload.mission_items = std::move(prepared_actions);
    vehicle.mission_upload.Set_next_action(
            Activity::Make_next_action(
                    &Task_upload::Mission_uploaded,
                    this));
    vehicle.mission_upload.Enable();

}

void
Ardupilot_vehicle::Task_upload::Mission_uploaded(bool success)
{
    if (!success) {
        VEHICLE_LOG_INF(vehicle, "Mission upload to vehicle failed, failing vehicle request.");
        request = Vehicle_request::Result::NOK;
        Disable();
        return;
    }
    /* Everything is OK. */
    request = Vehicle_request::Result::OK;
    Disable();
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_coords(
        mavlink::Pld_mission_item& msg,
        const Geodetic_tuple& tuple, double heading)
{
    msg->x = (tuple.latitude * 180.0) / M_PI;
    msg->y = (tuple.longitude * 180.0) / M_PI;
    /* Fixup absolute altitude - make them relative to
     * take-off altitude.
     */
    msg->z = tuple.altitude - request->Get_takeoff_altitude();
    msg->param4 = (heading * 180.0) / M_PI;
}

void
Ardupilot_vehicle::Task_upload::Fill_mavlink_mission_item_common(
        mavlink::Pld_mission_item& msg)
{
    ASSERT(vehicle.real_system_id != Mavlink_demuxer::SYSTEM_ID_ANY);

    Fill_target_ids(msg);
    msg->seq = prepared_actions.size();
    /* APM firmware treats all altitudes as relative. Always. */
    msg->frame = mavlink::MAV_FRAME::MAV_FRAME_GLOBAL_RELATIVE_ALT;
    msg->current = 0;
    msg->autocontinue = 1;
}

void
Ardupilot_vehicle::Task_upload::On_disable()
{
    if (request) {
        request = Vehicle_request::Result::NOK;
    }
    vehicle.write_parameters.Disable();
    vehicle.mission_upload.Disable();
    prepared_actions.clear();
    task_attributes.clear();
}

void
Ardupilot_vehicle::Task_upload::Filter_actions()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Filter_copter_actions();
        return;
    case Type::PLANE:
        Filter_plane_actions();
        return;
    case Type::ROVER:
        Filter_rover_actions();
        return;
    case Type::OTHER:
        Filter_other_actions();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d.",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Filter_copter_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
#if 0
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::CHANGE_SPEED:
            VEHICLE_LOG_WRN(vehicle, "SPEED action ignored.");
            break;
#endif
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_plane_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_rover_actions()
{
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::CAMERA_CONTROL:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_CONTROL action ignored.");
            break;
        case Action::Type::CAMERA_TRIGGER:
            VEHICLE_LOG_WRN(vehicle, "CAMERA_TRIGGER action ignored.");
            break;
        case Action::Type::PANORAMA:
            VEHICLE_LOG_WRN(vehicle, "PANORAMA action ignored.");
            break;
        case Action::Type::POI:
            VEHICLE_LOG_WRN(vehicle, "POI action ignored.");
            break;
        case Action::Type::HEADING:
            VEHICLE_LOG_WRN(vehicle, "HEADING action ignored.");
            break;
        default:
            iter++;
            continue;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Filter_other_actions()
{
    /* Only move is supported. Safe. */
    for (auto iter = request->actions.begin(); iter != request->actions.end();) {
        switch ((*iter)->Get_type()) {
        case Action::Type::MOVE:
            iter++;
            continue;
        default:
            VEHICLE_LOG_WRN(vehicle, "Action type %d ignored.", (*iter)->Get_type());
            break;
        }
        iter = request->actions.erase(iter);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task()
{
    prepared_actions.clear();

    /* Ardupilot waypoint at index zero is always treated as home position,
     * so ensure it is always present. In other words, real waypoint should not
     * be stored at zero index.
     */
    Set_home_action::Ptr set_home_action = Set_home_action::Create(
            false /* use specified. */,
            request->Get_home_position(),
            0 /* elevation. */);

    Prepare_action(set_home_action);

    bool first_set_home_found = false;

    last_move_action = nullptr;
    for (auto& iter:request->actions) {
        switch (iter->Get_type()) {
        case Action::Type::SET_HOME:
            if (!first_set_home_found) {
                /* Skip first set_home, it has been already processed and put
                 * into waypoint index zero. */
                first_set_home_found = true;
            } else {
                /* To be tested. */
                Prepare_action(iter);
            }
            break;
        default:
            Prepare_action(iter);
            break;
        }
    }

    if (last_move_action) {
        Prepare_action(last_move_action);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_task_attributes()
{
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        Prepare_copter_task_attributes();
        return;
    case Type::PLANE:
        Prepare_plane_task_attributes();
        return;
    case Type::ROVER:
        Prepare_rover_task_attributes();
        return;
    case Type::OTHER:
        Prepare_other_task_attributes();
        return;
    }
    VSM_EXCEPTION(Internal_error_exception, "Unhandled Ardupilot vehicle type %d",
            ardu_vehicle.Get_type());
}

void
Ardupilot_vehicle::Task_upload::Prepare_copter_task_attributes()
{
    task_attributes.clear();

    mavlink::Pld_param_set param;
    Fill_target_ids(param);
    using Emerg = Task_attributes_action::Emergency_action;

    /* Battery failsafe. */
    param->param_id = "FS_BATT_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->low_battery) {
    case Emerg::GO_HOME:
        param->param_value = 2;
        break;
    case Emerg::LAND:
        param->param_value = 1;
        break;
    case Emerg::WAIT:
        /* There is no support for such behavior. Override with land. */
        param->param_value = 1;
        break;
    case Emerg::CONTINUE:
        param->param_value = 0;
        break;
    }
    task_attributes.push_back(param);

    /* GNSS loss failsafe. */
    param->param_id = "FS_GPS_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->gnss_loss) {
    case Emerg::GO_HOME:
        /* Shouldn't be received at all. */
        param->param_value = 3;
        break;
    case Emerg::LAND:
        param->param_value = 3;
        break;
    case Emerg::WAIT:
        param->param_value = 2;
        break;
    case Emerg::CONTINUE:
        param->param_value = 0;
        break;
    }
    task_attributes.push_back(param);

    /* Radio Control loss failsafe. */
    param->param_id = "FS_THR_ENABLE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    switch (request->attributes->rc_loss) {
    case Emerg::GO_HOME:
        param->param_value = 1;
        break;
    case Emerg::LAND:
        param->param_value = 3;
        break;
    case Emerg::WAIT:
        /* Wait not supported, do land. */
        param->param_value = 3;
        break;
    case Emerg::CONTINUE:
        /* Continue in auto, land in other modes. */
        param->param_value = 2;
        break;
    }
    task_attributes.push_back(param);

    /* Don't change yaw during auto mission, because there is an auto-POI
     * feature. Besides that, duplicated waypoints are used to implement
     * actions like panorama, so it is not desirable to change the yaw while
     * switching between waypoints sharing the same location. */
    param->param_id = "WP_YAW_BEHAVIOR";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 0; /* Never change yaw. */
    task_attributes.push_back(param);

#if 0 /* Wait until supported. */
    /* Mount control mode. */
    param->param_id = "MNT_MODE";
    param->param_type = mavlink::MAV_PARAM_TYPE::MAV_PARAM_TYPE_INT8;
    param->param_value = 2; /* Mavlink targeting. */
    task_attributes.push_back(param);
#endif

}

void
Ardupilot_vehicle::Task_upload::Prepare_plane_task_attributes()
{
    /* Wait until UCS becomes 'plane-aware'. */
    task_attributes.clear();
}

void
Ardupilot_vehicle::Task_upload::Prepare_rover_task_attributes()
{
    /* Wait until UCS becomes 'rover-aware'. */
    task_attributes.clear();
}

void
Ardupilot_vehicle::Task_upload::Prepare_other_task_attributes()
{
    /* Stub. */
    task_attributes.clear();
}

void
Ardupilot_vehicle::Task_upload::Prepare_action(Action::Ptr action)
{
    switch (action->Get_type()) {
    case Action::Type::MOVE:
        Prepare_move(action);
        return;
    case Action::Type::WAIT:
        Prepare_wait(action);
        return;
    case Action::Type::PAYLOAD_STEERING:
        Prepare_payload_steering(action);
        return;
    case Action::Type::TAKEOFF:
        Prepare_takeoff(action);
        return;
    case Action::Type::LANDING:
        Prepare_landing(action);
        return;
    case Action::Type::CHANGE_SPEED:
        Prepare_change_speed(action);
        return;
    case Action::Type::SET_HOME:
        Prepare_set_home(action);
        return;
    case Action::Type::POI:
        Prepare_POI(action);
        return;
    case Action::Type::HEADING:
        Prepare_heading(action);
        return;
    case Action::Type::PANORAMA:
        Prepare_panorama(action);
        return;
    case Action::Type::CAMERA_CONTROL:
        VSM_EXCEPTION(Internal_error_exception, "CAMERA_CONTROL action not supported.");
    case Action::Type::CAMERA_TRIGGER:
        VSM_EXCEPTION(Internal_error_exception, "CAMERA_TRIGGER action not supported.");
    case Action::Type::TASK_ATTRIBUTES:
        VSM_EXCEPTION(Internal_error_exception, "TASK_ATTRIBUTES action not supported.");
    }
    VSM_EXCEPTION(Internal_error_exception, "Unsupported action [%s]",
            action->Get_name().c_str());
}

void
Ardupilot_vehicle::Task_upload::Add_mission_item(mavlink::Pld_mission_item::Ptr mi)
{
    Fill_mavlink_mission_item_common(*mi);
    prepared_actions.push_back(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_move(Action::Ptr& action)
{
    Add_mission_item(Build_wp_mission_item(action));
    last_move_action = action;
}

void
Ardupilot_vehicle::Task_upload::Prepare_wait(Action::Ptr& action)
{
    /* Create additional waypoint on the current position to wait. */
    if (last_move_action) {
        auto wp = Build_wp_mission_item(last_move_action);
        Wait_action::Ptr wa = action->Get_action<Action::Type::WAIT>();
        (*wp)->param1 = wa->wait_time;
        Add_mission_item(wp);
    } else {
        VEHICLE_LOG_WRN(vehicle, "No move action before wait action, ignored.");
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_payload_steering(Action::Ptr&)
{
    ASSERT(false); /* Not implemented yet */
}

void
Ardupilot_vehicle::Task_upload::Prepare_takeoff(Action::Ptr& action)
{
    /* Ardupilot does not fly to the takeoff position after takeoff
     * is done. Add explicit waypoint after the takeoff command with
     * target coordinates.
     */
    auto takeoff = action->Get_action<Action::Type::TAKEOFF>();
    auto explicit_wp = Move_action::Create(
            takeoff->position,
            0,
            takeoff->acceptance_radius,
            0,
            takeoff->heading,
            takeoff->elevation
    );

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_TAKEOFF;
    (*mi)->param1 = 0; /* No data for pitch. */
    Fill_mavlink_mission_item_coords(*mi, takeoff->position.Get_geodetic(), takeoff->heading);
    Add_mission_item(mi);
    Prepare_action(explicit_wp);
}

void
Ardupilot_vehicle::Task_upload::Prepare_landing(Action::Ptr& action)
{
    /* Ardupilot does not take the altitude of the landing, so
     * add explicit waypoint guiding vehicle to the landing start
     * position.
     */
    auto land = action->Get_action<Action::Type::LANDING>();
    auto explicit_wp = Move_action::Create(
            land->position,
            0,
            land->acceptance_radius,
            0,
            land->heading,
            land->elevation
    );
    Prepare_action(explicit_wp);

    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_LAND;
    Fill_mavlink_mission_item_coords(*mi, land->position.Get_geodetic(), land->heading);
    Add_mission_item(mi);

    /* Don't duplicate waypoint if last action is land. */
    last_move_action = nullptr;
}

void
Ardupilot_vehicle::Task_upload::Prepare_change_speed(Action::Ptr& action)
{
    Change_speed_action::Ptr la = action->Get_action<Action::Type::CHANGE_SPEED>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_CHANGE_SPEED;
    switch (ardu_vehicle.Get_type()) {
    case Type::COPTER:
        /* Copters use p1 as navigation speed always. */
        (*mi)->param1 = la->speed;
        (*mi)->param2 = 0; /* unused */
        break;
    case Type::ROVER:
    default:
        /* Ground rover takes only airspeed into account, others seems to
         * take both, but we have only airspeed from UCS, so use only air. */
        (*mi)->param1 = 0; /* Airspeed. */
        (*mi)->param2 = la->speed;
        break;
    }

    (*mi)->param3 = -1; /* Throttle no change. */
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_set_home(Action::Ptr& action)
{
    Set_home_action::Ptr sa = action->Get_action<Action::Type::SET_HOME>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_HOME;
    (*mi)->param1 = sa->use_current_position ? 1 : 0;
    Fill_mavlink_mission_item_coords(*mi, sa->home_position.Get_geodetic(), 0);
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_POI(Action::Ptr& action)
{
    /* Apply only active POI. */
    if (action->Get_action<Action::Type::POI>()->active) {
        Poi_action::Ptr pa = action->Get_action<Action::Type::POI>();
        mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
        (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_SET_ROI;
        (*mi)->param1 = mavlink::MAV_ROI::MAV_ROI_LOCATION;
        Fill_mavlink_mission_item_coords(*mi, pa->position.Get_geodetic(), 0);
        Add_mission_item(mi);
    }
}

void
Ardupilot_vehicle::Task_upload::Prepare_heading(Action::Ptr& action)
{
    Heading_action::Ptr ha = action->Get_action<Action::Type::HEADING>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
    (*mi)->param1 = (ha->heading * 180.0) / M_PI;
    (*mi)->param2 = 0; /* Default auto speed. */
    (*mi)->param3 = 1; /* clockwise. */
    (*mi)->param4 = 0; /* absolute angle. */
    Add_mission_item(mi);
}

void
Ardupilot_vehicle::Task_upload::Prepare_panorama(Action::Ptr& action)
{
    Panorama_action::Ptr panorama = action->Get_action<Action::Type::PANORAMA>();

    if (!last_move_action) {
        VEHICLE_LOG_WRN(vehicle, "No previous move action found to generate panorama action, ignored.");
        return;
    }
    /* Create additional waypoint at the current position with wait to
     * stabilize before doing panorama. */
    auto panorama_pre_wait = Build_wp_mission_item(last_move_action);
    (*panorama_pre_wait)->param1 = 3; /* seconds. */
    Add_mission_item(panorama_pre_wait);

    /* Panorama is always done in steps less then 180 degree to make sure that
     * turns over 180 degrees are supported.
     */
    double min_step = 170;
    double full_angle = (std::abs(panorama->angle) * 180.0) / M_PI;
    double speed = (std::abs(panorama->speed) * 180.0) / M_PI;
    double step = 0;
    int delay = 0;

    if (!speed || speed > 60) {
        speed = 60; /* Degrees/second assumed max speed. */
    }

    double panorama_duration = full_angle / speed;

    switch (panorama->trigger_state) {
    case Panorama_action::Trigger_state::ON:
        step = min_step;
        delay = 0;
        break;
    case Panorama_action::Trigger_state::SERIAL:
        step = (std::abs(panorama->step) * 180.0) / M_PI;
        /* Per-sector delay. */
        delay = std::chrono::duration_cast<std::chrono::seconds>(panorama->delay).count();
        break;
    }

    if (!step) {
        VEHICLE_LOG_WRN(vehicle, "Zero step angle, ignoring panorama.");
        return;
    }

    double completed_angle = 0;
    while (completed_angle + 0.1 < full_angle) {
        double split_angle = completed_angle;
        /* Add step desired by user. */
        completed_angle += step;
        /* Don't exceed the maximum angle, even if it does not evenly divides
         * to desired step intervals.
         */
        if (completed_angle > full_angle) {
            completed_angle = full_angle;
        }
        /* If desired step is more that 180 degrees, it should be split in
         * min_step intervals, otherwise Ardupilot makes the shorter turn.
         */
        while (split_angle + 0.1 < completed_angle) {
            double diff = split_angle;
            split_angle += min_step;
            if (split_angle > completed_angle) {
                split_angle = completed_angle;
            }
            diff = split_angle - diff;
            /* Turn is relative to current position. */
            mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
            (*mi)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_YAW;
            (*mi)->param1 = diff;
            double val = diff / speed;
            if (val < 1) {
                val = 1; /* Fastest possible speed. */
            }
            (*mi)->param2 = val;
            (*mi)->param3 = panorama->angle > 0 ? 1 /* clockwise. */ : 0 /* ccw */;
            (*mi)->param4 = 1; /* relative angle. */
            Add_mission_item(mi);
        }
        if (delay) {
            /* Add delay after each segment. */
            auto wait_segment = mavlink::Pld_mission_item::Create();
            (*wait_segment)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_DELAY;
            (*wait_segment)->param1 = delay;
            Add_mission_item(wait_segment);
        }
    }

/* Needed only if jump is used. */
#if 0
    /* Delay for 3 seconds to stabilize after panorama is done. */
    auto wait_after = mavlink::Pld_mission_item::Create();
    (*wait_after)->command = mavlink::MAV_CMD::MAV_CMD_CONDITION_DELAY;
    (*wait_after)->param1 = 3;
    Add_mission_item(wait_after);
#endif

/* Ardupilot jump command is broken (bug). It works only once, so don't use it. */
#if 0
    /* Jump to next waypoint and interrupt "pseudo indefinite wait" of
     * 255 seconds.
     */
    mavlink::Pld_mission_item::Ptr jump = mavlink::Pld_mission_item::Create();
    (*jump)->command = mavlink::MAV_CMD::MAV_CMD_DO_JUMP;
    (*jump)->param2 = 1; /* Repeat once. */
    /* Skip next long wait waypoint and jump to 'jump_to'. */
    (*jump)->param1 = prepared_actions.size() + 2;
    Add_mission_item(jump);
#endif

    /* Create a waypoint with hold time slightly more than estimated
     * panorama duration.
     */
    auto long_wait = Build_wp_mission_item(last_move_action);
    if (panorama_duration + 5 > 255) {
        VEHICLE_LOG_WRN(vehicle, "Estimated panorama duration is truncated to 255 seconds.");
        (*long_wait)->param1 = 255; /* Max possible wait for Ardupilot. */
    } else {
        (*long_wait)->param1 = panorama_duration + 5;
    }
    Add_mission_item(long_wait);

/* Not needed without jump. */
#if 0
    auto jump_to = Build_wp_mission_item(last_move_action);
    /* Don't wait. Ardupilot does not support (most probably bug) jumping
     * to waypoints with non-zero wait. */
    (*jump_to)->param1 = 0;
    Add_mission_item(jump_to);
#endif
}

void
Ardupilot_vehicle::Task_upload::Prepare_camera_control(Action::Ptr& action)
{
    Camera_control_action::Ptr cam_control =
            action->Get_action<Action::Type::CAMERA_CONTROL>();

    /* TODO wait until supported by Ardupilot. */
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_DO_MOUNT_CONTROL;
    Add_mission_item(mi);

}

mavlink::Pld_mission_item::Ptr
Ardupilot_vehicle::Task_upload::Build_wp_mission_item(Action::Ptr& action)
{
    Move_action::Ptr ma = action->Get_action<Action::Type::MOVE>();
    mavlink::Pld_mission_item::Ptr mi = mavlink::Pld_mission_item::Create();
    (*mi)->command = mavlink::MAV_CMD::MAV_CMD_NAV_WAYPOINT;
    (*mi)->param1 = ma->wait_time * 10;
    /* Set acceptance radius to something reasonable. */
    if (ma->acceptance_radius < ACCEPTANCE_RADIUS_MIN) {
        (*mi)->param2 = ACCEPTANCE_RADIUS_MIN;
        VEHICLE_LOG_INF(vehicle, "Acceptance radius normalized from %f to %f",
                ma->acceptance_radius, (*mi)->param2.Get());
    } else {
        (*mi)->param2 = ma->acceptance_radius;
    }
    (*mi)->param3 = ma->loiter_orbit;
    Fill_mavlink_mission_item_coords(*mi, ma->position.Get_geodetic(), ma->heading);

    return mi;
}

void
Ardupilot_vehicle::Process_heartbeat(
            ugcs::vsm::mavlink::Message<ugcs::vsm::mavlink::MESSAGE_ID::HEARTBEAT>::Ptr message)
{
    Sys_status::Control_mode control_mode = Sys_status::Control_mode::UNKNOWN;
    switch (Get_type()) {
    case Type::COPTER:
        control_mode = Map_copter_flight_mode(static_cast<Copter_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::ROVER:
        control_mode = Map_rover_flight_mode(static_cast<Rover_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::PLANE:
        control_mode = Map_plane_flight_mode(static_cast<Plane_flight_mode>(
                message->payload->custom_mode.Get()));
        break;
    case Type::OTHER:;
    }

    Sys_status::State state = Sys_status::State::DISARMED;
    if (message->payload->base_mode.Get() & mavlink::MAV_MODE_FLAG::MAV_MODE_FLAG_SAFETY_ARMED) {
        state = Sys_status::State::ARMED;
    }

    auto uptime = std::chrono::duration_cast<std::chrono::seconds>(
            std::chrono::steady_clock::now() - recent_connect);

    Set_system_status(Sys_status(true, true, control_mode, state, uptime));
    Update_capability_states();
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_copter_flight_mode(Copter_flight_mode custom_mode)
{

    switch (custom_mode) {
    case Copter_flight_mode::AUTO:
    case Copter_flight_mode::GUIDED:
    case Copter_flight_mode::RTL:
    case Copter_flight_mode::CIRCLE:
    case Copter_flight_mode::LAND:
    case Copter_flight_mode::AUTOTUNE:
        return Sys_status::Control_mode::AUTO;
    case Copter_flight_mode::STABILIZE:
    case Copter_flight_mode::ACRO:
    case Copter_flight_mode::ALT_HOLD:
    case Copter_flight_mode::OF_LOITER:
    case Copter_flight_mode::LOITER:
    case Copter_flight_mode::DRIFT:
    case Copter_flight_mode::SPORT:
    case Copter_flight_mode::FLIP:
        return Sys_status::Control_mode::MANUAL;
    }
    return Sys_status::Control_mode::UNKNOWN;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_plane_flight_mode(Plane_flight_mode custom_mode)
{
    switch (custom_mode) {
    case Plane_flight_mode::AUTO:
    case Plane_flight_mode::LOITER:
    case Plane_flight_mode::CIRCLE:
    case Plane_flight_mode::RTL:
    case Plane_flight_mode::GUIDED:
        return Sys_status::Control_mode::AUTO;
    case Plane_flight_mode::MANUAL:
    case Plane_flight_mode::STABILIZE:
    case Plane_flight_mode::TRAINING:
    case Plane_flight_mode::ACRO:
    case Plane_flight_mode::FLY_BY_WIRE_A:
    case Plane_flight_mode::FLY_BY_WIRE_B:
    case Plane_flight_mode::CRUISE:
        return Sys_status::Control_mode::MANUAL;
    case Plane_flight_mode::INITIALISING:;
        /* Fall down to unknown. */
    }

    return Sys_status::Control_mode::UNKNOWN;
}

Vehicle::Sys_status::Control_mode
Ardupilot_vehicle::Map_rover_flight_mode(Rover_flight_mode custom_mode)
{
    switch (custom_mode) {
    case Rover_flight_mode::AUTO:
    case Rover_flight_mode::RTL:
    case Rover_flight_mode::GUIDED:
        return Sys_status::Control_mode::AUTO;
    case Rover_flight_mode::MANUAL:
    case Rover_flight_mode::LEARNING:
    case Rover_flight_mode::STEERING:
    case Rover_flight_mode::HOLD:
        return Sys_status::Control_mode::MANUAL;
    case Rover_flight_mode::INITIALISING:;
    /* Fall down to unknown. */
    }

    return Sys_status::Control_mode::UNKNOWN;
}

void
Ardupilot_vehicle::Update_capabilities()
{
    switch (Get_type()) {
    case Type::COPTER:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::ARM_AVAILABLE,
                    Vehicle::Capability::DISARM_AVAILABLE,
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::LAND_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::PLANE:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::ARM_AVAILABLE,
                    Vehicle::Capability::DISARM_AVAILABLE,
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::ROVER:
        Set_capabilities(
            Capabilities(
                    Vehicle::Capability::AUTO_MODE_AVAILABLE,
                    Vehicle::Capability::MANUAL_MODE_AVAILABLE,
                    Vehicle::Capability::RETURN_HOME_AVAILABLE));
        return;
    case Type::OTHER:;
    }
    /* Others don't support anything. */
    Set_capabilities(Capabilities());
}

void
Ardupilot_vehicle::Update_capability_states()
{
    Capability_states states;
    auto status = Get_system_status();

    switch (Get_type()) {
    case Type::COPTER:
        states.Set(Capability_state::ARM_ENABLED);
        states.Set(Capability_state::DISARM_ENABLED);
        if (status.state == Sys_status::State::ARMED) {
            states.Set(Capability_state::AUTO_MODE_ENABLED);
            states.Set(Capability_state::MANUAL_MODE_ENABLED);
            states.Set(Capability_state::RETURN_HOME_ENABLED);
            states.Set(Capability_state::LAND_ENABLED);
        }
        break;
    case Type::PLANE:
        states.Set(Capability_state::ARM_ENABLED);
        states.Set(Capability_state::DISARM_ENABLED);
        if (status.state == Sys_status::State::ARMED) {
            states.Set(Capability_state::AUTO_MODE_ENABLED);
            states.Set(Capability_state::MANUAL_MODE_ENABLED);
            states.Set(Capability_state::RETURN_HOME_ENABLED);
        }
        break;
    case Type::ROVER:
        states.Set(Capability_state::AUTO_MODE_ENABLED);
        states.Set(Capability_state::MANUAL_MODE_ENABLED);
        states.Set(Capability_state::RETURN_HOME_ENABLED);
        break;
    case Type::OTHER:;
    }
    Set_capability_states(states);
}
